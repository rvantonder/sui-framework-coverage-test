// Move bytecode v6
module 2.safe {
use 0000000000000000000000000000000000000002::balance;
use 0000000000000000000000000000000000000002::coin;
use 0000000000000000000000000000000000000002::object;
use 0000000000000000000000000000000000000002::transfer;
use 0000000000000000000000000000000000000002::tx_context;
use 0000000000000000000000000000000000000002::vec_set;


struct OwnerCapability<phantom T> has store, key {
	id: UID,
	safe_id: ID
}
struct Safe<phantom T> has key {
	id: UID,
	balance: Balance<T>,
	allowed_safes: VecSet<ID>
}
struct TransferCapability<phantom T> has store, key {
	id: UID,
	safe_id: ID,
	amount: u64
}

public balance<T>(safe: &Safe<T>): &Balance<T> {
B0:
	0: MoveLoc[0](safe: &Safe<T>)
	1: ImmBorrowFieldGeneric[0](Safe.balance: Balance<T>)
	2: Ret
}
check_capability_validity<T>(safe: &Safe<T>, capability: &TransferCapability<T>) {
B0:
	0: CopyLoc[0](safe: &Safe<T>)
	1: Call object::id<Safe<T>>(&Safe<T>): ID
	2: CopyLoc[1](capability: &TransferCapability<T>)
	3: ImmBorrowFieldGeneric[1](TransferCapability.safe_id: ID)
	4: ReadRef
	5: Eq
	6: BrFalse(8)
B1:
	7: Branch(14)
B2:
	8: MoveLoc[0](safe: &Safe<T>)
	9: Pop
	10: MoveLoc[1](capability: &TransferCapability<T>)
	11: Pop
	12: LdConst[1](U64: [0, 0, 0, 0, 0, 0, 0, 0])
	13: Abort
B3:
	14: MoveLoc[0](safe: &Safe<T>)
	15: ImmBorrowFieldGeneric[2](Safe.allowed_safes: VecSet<ID>)
	16: StLoc[3](%#2: &VecSet<ID>)
	17: MoveLoc[1](capability: &TransferCapability<T>)
	18: Call object::id<TransferCapability<T>>(&TransferCapability<T>): ID
	19: StLoc[2](%#1: ID)
	20: MoveLoc[3](%#2: &VecSet<ID>)
	21: ImmBorrowLoc[2](%#1: ID)
	22: Call vec_set::contains<ID>(&VecSet<ID>, &ID): bool
	23: BrFalse(25)
B4:
	24: Branch(27)
B5:
	25: LdConst[4](U64: [2, 0, 0, 0, 0, 0, 0, 0])
	26: Abort
B6:
	27: Ret
}
check_owner_capability_validity<T>(safe: &Safe<T>, capability: &OwnerCapability<T>) {
B0:
	0: MoveLoc[0](safe: &Safe<T>)
	1: Call object::id<Safe<T>>(&Safe<T>): ID
	2: MoveLoc[1](capability: &OwnerCapability<T>)
	3: ImmBorrowFieldGeneric[3](OwnerCapability.safe_id: ID)
	4: ReadRef
	5: Eq
	6: BrFalse(8)
B1:
	7: Branch(10)
B2:
	8: LdConst[0](U64: [1, 0, 0, 0, 0, 0, 0, 0])
	9: Abort
B3:
	10: Ret
}
entry public create<T>(coin: Coin<T>, ctx: &mut TxContext) {
B0:
	0: MoveLoc[0](coin: Coin<T>)
	1: Call coin::into_balance<T>(Coin<T>): Balance<T>
	2: CopyLoc[1](ctx: &mut TxContext)
	3: Call create_<T>(Balance<T>, &mut TxContext): OwnerCapability<T>
	4: MoveLoc[1](ctx: &mut TxContext)
	5: FreezeRef
	6: Call tx_context::sender(&TxContext): address
	7: Call transfer::transfer<OwnerCapability<T>>(OwnerCapability<T>, address)
	8: Ret
}
public create_<T>(balance: Balance<T>, ctx: &mut TxContext): OwnerCapability<T> {
B0:
	0: CopyLoc[1](ctx: &mut TxContext)
	1: Call object::new(&mut TxContext): UID
	2: MoveLoc[0](balance: Balance<T>)
	3: Call vec_set::empty<ID>(): VecSet<ID>
	4: PackGeneric[0](Safe<T>)
	5: StLoc[3](safe: Safe<T>)
	6: MoveLoc[1](ctx: &mut TxContext)
	7: Call object::new(&mut TxContext): UID
	8: ImmBorrowLoc[3](safe: Safe<T>)
	9: Call object::id<Safe<T>>(&Safe<T>): ID
	10: PackGeneric[1](OwnerCapability<T>)
	11: StLoc[2](cap: OwnerCapability<T>)
	12: MoveLoc[3](safe: Safe<T>)
	13: Call transfer::share_object<Safe<T>>(Safe<T>)
	14: MoveLoc[2](cap: OwnerCapability<T>)
	15: Ret
}
create_capability_<T>(safe: &mut Safe<T>, withdraw_amount: u64, ctx: &mut TxContext): TransferCapability<T> {
B0:
	0: MoveLoc[2](ctx: &mut TxContext)
	1: Call object::new(&mut TxContext): UID
	2: StLoc[3](cap_id: UID)
	3: CopyLoc[0](safe: &mut Safe<T>)
	4: MutBorrowFieldGeneric[2](Safe.allowed_safes: VecSet<ID>)
	5: ImmBorrowLoc[3](cap_id: UID)
	6: Call object::uid_to_inner(&UID): ID
	7: Call vec_set::insert<ID>(&mut VecSet<ID>, ID)
	8: MoveLoc[3](cap_id: UID)
	9: MoveLoc[0](safe: &mut Safe<T>)
	10: ImmBorrowFieldGeneric[4](Safe.id: UID)
	11: Call object::uid_to_inner(&UID): ID
	12: MoveLoc[1](withdraw_amount: u64)
	13: PackGeneric[2](TransferCapability<T>)
	14: Ret
}
entry public create_empty<T>(ctx: &mut TxContext) {
B0:
	0: Call balance::zero<T>(): Balance<T>
	1: CopyLoc[0](ctx: &mut TxContext)
	2: Call create_<T>(Balance<T>, &mut TxContext): OwnerCapability<T>
	3: MoveLoc[0](ctx: &mut TxContext)
	4: FreezeRef
	5: Call tx_context::sender(&TxContext): address
	6: Call transfer::transfer<OwnerCapability<T>>(OwnerCapability<T>, address)
	7: Ret
}
public create_transfer_capability<T>(safe: &mut Safe<T>, capability: &OwnerCapability<T>, withdraw_amount: u64, ctx: &mut TxContext): TransferCapability<T> {
B0:
	0: CopyLoc[0](safe: &mut Safe<T>)
	1: MoveLoc[1](capability: &OwnerCapability<T>)
	2: StLoc[4](%#2: &OwnerCapability<T>)
	3: FreezeRef
	4: MoveLoc[4](%#2: &OwnerCapability<T>)
	5: Call check_owner_capability_validity<T>(&Safe<T>, &OwnerCapability<T>)
	6: MoveLoc[0](safe: &mut Safe<T>)
	7: MoveLoc[2](withdraw_amount: u64)
	8: MoveLoc[3](ctx: &mut TxContext)
	9: Call create_capability_<T>(&mut Safe<T>, u64, &mut TxContext): TransferCapability<T>
	10: Ret
}
public debit<T>(safe: &mut Safe<T>, capability: &mut TransferCapability<T>, withdraw_amount: u64): Balance<T> {
B0:
	0: CopyLoc[0](safe: &mut Safe<T>)
	1: CopyLoc[1](capability: &mut TransferCapability<T>)
	2: StLoc[3](%#2: &mut TransferCapability<T>)
	3: FreezeRef
	4: MoveLoc[3](%#2: &mut TransferCapability<T>)
	5: FreezeRef
	6: Call check_capability_validity<T>(&Safe<T>, &TransferCapability<T>)
	7: CopyLoc[1](capability: &mut TransferCapability<T>)
	8: ImmBorrowFieldGeneric[5](TransferCapability.amount: u64)
	9: ReadRef
	10: CopyLoc[2](withdraw_amount: u64)
	11: Ge
	12: BrFalse(14)
B1:
	13: Branch(20)
B2:
	14: MoveLoc[0](safe: &mut Safe<T>)
	15: Pop
	16: MoveLoc[1](capability: &mut TransferCapability<T>)
	17: Pop
	18: LdConst[3](U64: [3, 0, 0, 0, 0, 0, 0, 0])
	19: Abort
B3:
	20: CopyLoc[1](capability: &mut TransferCapability<T>)
	21: ImmBorrowFieldGeneric[5](TransferCapability.amount: u64)
	22: ReadRef
	23: CopyLoc[2](withdraw_amount: u64)
	24: Sub
	25: MoveLoc[1](capability: &mut TransferCapability<T>)
	26: MutBorrowFieldGeneric[5](TransferCapability.amount: u64)
	27: WriteRef
	28: MoveLoc[0](safe: &mut Safe<T>)
	29: MutBorrowFieldGeneric[0](Safe.balance: Balance<T>)
	30: MoveLoc[2](withdraw_amount: u64)
	31: Call balance::split<T>(&mut Balance<T>, u64): Balance<T>
	32: Ret
}
entry public deposit<T>(safe: &mut Safe<T>, coin: Coin<T>) {
B0:
	0: MoveLoc[1](coin: Coin<T>)
	1: Call coin::into_balance<T>(Coin<T>): Balance<T>
	2: StLoc[2](balance: Balance<T>)
	3: MoveLoc[0](safe: &mut Safe<T>)
	4: MoveLoc[2](balance: Balance<T>)
	5: Call deposit_<T>(&mut Safe<T>, Balance<T>)
	6: Ret
}
public deposit_<T>(safe: &mut Safe<T>, balance: Balance<T>) {
B0:
	0: MoveLoc[0](safe: &mut Safe<T>)
	1: MutBorrowFieldGeneric[0](Safe.balance: Balance<T>)
	2: MoveLoc[1](balance: Balance<T>)
	3: Call balance::join<T>(&mut Balance<T>, Balance<T>): u64
	4: Pop
	5: Ret
}
entry public revoke_transfer_capability<T>(safe: &mut Safe<T>, capability: &OwnerCapability<T>, capability_id: ID) {
B0:
	0: CopyLoc[0](safe: &mut Safe<T>)
	1: MoveLoc[1](capability: &OwnerCapability<T>)
	2: StLoc[3](%#2: &OwnerCapability<T>)
	3: FreezeRef
	4: MoveLoc[3](%#2: &OwnerCapability<T>)
	5: Call check_owner_capability_validity<T>(&Safe<T>, &OwnerCapability<T>)
	6: MoveLoc[0](safe: &mut Safe<T>)
	7: MutBorrowFieldGeneric[2](Safe.allowed_safes: VecSet<ID>)
	8: ImmBorrowLoc[2](capability_id: ID)
	9: Call vec_set::remove<ID>(&mut VecSet<ID>, &ID)
	10: Ret
}
entry public self_revoke_transfer_capability<T>(safe: &mut Safe<T>, capability: &TransferCapability<T>) {
L0:	%#4: &mut VecSet<ID>
B0:
	0: CopyLoc[0](safe: &mut Safe<T>)
	1: CopyLoc[1](capability: &TransferCapability<T>)
	2: StLoc[2](%#2: &TransferCapability<T>)
	3: FreezeRef
	4: MoveLoc[2](%#2: &TransferCapability<T>)
	5: Call check_capability_validity<T>(&Safe<T>, &TransferCapability<T>)
	6: MoveLoc[0](safe: &mut Safe<T>)
	7: MutBorrowFieldGeneric[2](Safe.allowed_safes: VecSet<ID>)
	8: StLoc[4](%#4: &mut VecSet<ID>)
	9: MoveLoc[1](capability: &TransferCapability<T>)
	10: Call object::id<TransferCapability<T>>(&TransferCapability<T>): ID
	11: StLoc[3](%#3: ID)
	12: MoveLoc[4](%#4: &mut VecSet<ID>)
	13: ImmBorrowLoc[3](%#3: ID)
	14: Call vec_set::remove<ID>(&mut VecSet<ID>, &ID)
	15: Ret
}
entry public withdraw<T>(safe: &mut Safe<T>, capability: &OwnerCapability<T>, withdraw_amount: u64, ctx: &mut TxContext) {
B0:
	0: MoveLoc[0](safe: &mut Safe<T>)
	1: MoveLoc[1](capability: &OwnerCapability<T>)
	2: MoveLoc[2](withdraw_amount: u64)
	3: Call withdraw_<T>(&mut Safe<T>, &OwnerCapability<T>, u64): Balance<T>
	4: CopyLoc[3](ctx: &mut TxContext)
	5: Call coin::from_balance<T>(Balance<T>, &mut TxContext): Coin<T>
	6: MoveLoc[3](ctx: &mut TxContext)
	7: FreezeRef
	8: Call tx_context::sender(&TxContext): address
	9: Call transfer::transfer<Coin<T>>(Coin<T>, address)
	10: Ret
}
public withdraw_<T>(safe: &mut Safe<T>, capability: &OwnerCapability<T>, withdraw_amount: u64): Balance<T> {
B0:
	0: CopyLoc[0](safe: &mut Safe<T>)
	1: MoveLoc[1](capability: &OwnerCapability<T>)
	2: StLoc[3](%#2: &OwnerCapability<T>)
	3: FreezeRef
	4: MoveLoc[3](%#2: &OwnerCapability<T>)
	5: Call check_owner_capability_validity<T>(&Safe<T>, &OwnerCapability<T>)
	6: MoveLoc[0](safe: &mut Safe<T>)
	7: MutBorrowFieldGeneric[0](Safe.balance: Balance<T>)
	8: MoveLoc[2](withdraw_amount: u64)
	9: Call balance::split<T>(&mut Balance<T>, u64): Balance<T>
	10: Ret
}
}
