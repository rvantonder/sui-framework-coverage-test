// Move bytecode v6
module 2.sui_system {
use 0000000000000000000000000000000000000001::option;
use 0000000000000000000000000000000000000002::balance;
use 0000000000000000000000000000000000000002::coin;
use 0000000000000000000000000000000000000002::epoch_time_lock;
use 0000000000000000000000000000000000000002::event;
use 0000000000000000000000000000000000000002::locked_coin;
use 0000000000000000000000000000000000000002::object;
use 0000000000000000000000000000000000000002::pay;
use 0000000000000000000000000000000000000002::stake;
use 0000000000000000000000000000000000000002::stake_subsidy;
use 0000000000000000000000000000000000000002::staking_pool;
use 0000000000000000000000000000000000000002::sui;
use 0000000000000000000000000000000000000002::transfer;
use 0000000000000000000000000000000000000002::tx_context;
use 0000000000000000000000000000000000000002::validator;
use 0000000000000000000000000000000000000002::validator_set;
use 0000000000000000000000000000000000000002::vec_map;
use 0000000000000000000000000000000000000002::vec_set;


struct SuiSystemState has key {
	id: UID,
	epoch: u64,
	validators: ValidatorSet,
	sui_supply: Supply<SUI>,
	storage_fund: Balance<SUI>,
	parameters: SystemParameters,
	reference_gas_price: u64,
	validator_report_records: VecMap<address, VecSet<address>>,
	stake_subsidy: StakeSubsidy,
	safe_mode: bool,
	epoch_start_timestamp_ms: u64
}
struct SystemEpochInfo has copy, drop {
	epoch: u64,
	reference_gas_price: u64,
	total_stake: u64,
	storage_fund_inflows: u64,
	storage_fund_outflows: u64,
	storage_fund_balance: u64,
	stake_subsidy_amount: u64,
	total_gas_fees: u64,
	total_stake_rewards: u64
}
struct SystemParameters has store {
	min_validator_stake: u64,
	max_validator_candidate_count: u64
}

entry public advance_epoch(self: &mut SuiSystemState, new_epoch: u64, storage_charge: u64, computation_charge: u64, storage_rebate: u64, storage_fund_reinvest_rate: u64, reward_slashing_rate: u64, stake_subsidy_rate: u64, epoch_start_timestamp_ms: u64, ctx: &mut TxContext) {
L0:	storage_fund_reinvestment_amount: u128
L1:	storage_fund_reward: Balance<SUI>
L2:	storage_fund_reward_amount: u128
L3:	storage_reward: Balance<SUI>
L4:	total_rewards_amount: u64
L5:	total_stake: u64
L6:	total_stake_u128: u128
L7:	validator_stake: u64
B0:
	0: CopyLoc[9](ctx: &mut TxContext)
	1: FreezeRef
	2: Call tx_context::sender(&TxContext): address
	3: LdConst[8](Address: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
	4: Eq
	5: BrFalse(7)
B1:
	6: Branch(13)
B2:
	7: MoveLoc[0](self: &mut SuiSystemState)
	8: Pop
	9: MoveLoc[9](ctx: &mut TxContext)
	10: Pop
	11: LdU64(0)
	12: Abort
B3:
	13: MoveLoc[8](epoch_start_timestamp_ms: u64)
	14: CopyLoc[0](self: &mut SuiSystemState)
	15: MutBorrowField[0](SuiSystemState.epoch_start_timestamp_ms: u64)
	16: WriteRef
	17: LdConst[0](U128: [16, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
	18: CastU64
	19: StLoc[11](bps_denominator_u64: u64)
	20: CopyLoc[5](storage_fund_reinvest_rate: u64)
	21: CopyLoc[11](bps_denominator_u64: u64)
	22: Le
	23: BrFalse(29)
B4:
	24: CopyLoc[6](reward_slashing_rate: u64)
	25: MoveLoc[11](bps_denominator_u64: u64)
	26: Le
	27: StLoc[10](%#1: bool)
	28: Branch(31)
B5:
	29: LdFalse
	30: StLoc[10](%#1: bool)
B6:
	31: MoveLoc[10](%#1: bool)
	32: BrFalse(34)
B7:
	33: Branch(40)
B8:
	34: MoveLoc[0](self: &mut SuiSystemState)
	35: Pop
	36: MoveLoc[9](ctx: &mut TxContext)
	37: Pop
	38: LdConst[1](U64: [5, 0, 0, 0, 0, 0, 0, 0])
	39: Abort
B9:
	40: CopyLoc[0](self: &mut SuiSystemState)
	41: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	42: Call validator_set::total_delegation_stake(&ValidatorSet): u64
	43: StLoc[14](delegation_stake: u64)
	44: CopyLoc[0](self: &mut SuiSystemState)
	45: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	46: Call validator_set::total_validator_stake(&ValidatorSet): u64
	47: StLoc[27](validator_stake: u64)
	48: CopyLoc[0](self: &mut SuiSystemState)
	49: ImmBorrowField[2](SuiSystemState.storage_fund: Balance<SUI>)
	50: Call balance::value<SUI>(&Balance<SUI>): u64
	51: StLoc[18](storage_fund_balance: u64)
	52: CopyLoc[14](delegation_stake: u64)
	53: CopyLoc[27](validator_stake: u64)
	54: Add
	55: CopyLoc[18](storage_fund_balance: u64)
	56: Add
	57: StLoc[25](total_stake: u64)
	58: CopyLoc[2](storage_charge: u64)
	59: Call balance::create_staking_rewards<SUI>(u64): Balance<SUI>
	60: StLoc[23](storage_reward: Balance<SUI>)
	61: CopyLoc[3](computation_charge: u64)
	62: Call balance::create_staking_rewards<SUI>(u64): Balance<SUI>
	63: StLoc[13](computation_reward: Balance<SUI>)
	64: CopyLoc[0](self: &mut SuiSystemState)
	65: MutBorrowField[3](SuiSystemState.stake_subsidy: StakeSubsidy)
	66: CopyLoc[0](self: &mut SuiSystemState)
	67: MutBorrowField[4](SuiSystemState.sui_supply: Supply<SUI>)
	68: MoveLoc[7](stake_subsidy_rate: u64)
	69: MoveLoc[14](delegation_stake: u64)
	70: MoveLoc[27](validator_stake: u64)
	71: Add
	72: Call stake_subsidy::mint_stake_subsidy_proportional_to_total_stake_testnet(&mut StakeSubsidy, &mut Supply<SUI>, u64, u64)
	73: CopyLoc[0](self: &mut SuiSystemState)
	74: MutBorrowField[3](SuiSystemState.stake_subsidy: StakeSubsidy)
	75: Call stake_subsidy::withdraw_all(&mut StakeSubsidy): Balance<SUI>
	76: StLoc[16](stake_subsidy: Balance<SUI>)
	77: ImmBorrowLoc[16](stake_subsidy: Balance<SUI>)
	78: Call balance::value<SUI>(&Balance<SUI>): u64
	79: StLoc[17](stake_subsidy_amount: u64)
	80: MutBorrowLoc[13](computation_reward: Balance<SUI>)
	81: MoveLoc[16](stake_subsidy: Balance<SUI>)
	82: Call balance::join<SUI>(&mut Balance<SUI>, Balance<SUI>): u64
	83: Pop
	84: MoveLoc[25](total_stake: u64)
	85: CastU128
	86: StLoc[26](total_stake_u128: u128)
	87: CopyLoc[3](computation_charge: u64)
	88: CastU128
	89: StLoc[12](computation_charge_u128: u128)
	90: CopyLoc[0](self: &mut SuiSystemState)
	91: MutBorrowField[2](SuiSystemState.storage_fund: Balance<SUI>)
	92: MoveLoc[23](storage_reward: Balance<SUI>)
	93: Call balance::join<SUI>(&mut Balance<SUI>, Balance<SUI>): u64
	94: Pop
	95: MoveLoc[18](storage_fund_balance: u64)
	96: CastU128
	97: MoveLoc[12](computation_charge_u128: u128)
	98: Mul
	99: MoveLoc[26](total_stake_u128: u128)
	100: Div
	101: StLoc[22](storage_fund_reward_amount: u128)
	102: MutBorrowLoc[13](computation_reward: Balance<SUI>)
	103: CopyLoc[22](storage_fund_reward_amount: u128)
	104: CastU64
	105: Call balance::split<SUI>(&mut Balance<SUI>, u64): Balance<SUI>
	106: StLoc[21](storage_fund_reward: Balance<SUI>)
	107: MoveLoc[22](storage_fund_reward_amount: u128)
	108: MoveLoc[5](storage_fund_reinvest_rate: u64)
	109: CastU128
	110: Mul
	111: LdConst[0](U128: [16, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
	112: Div
	113: StLoc[20](storage_fund_reinvestment_amount: u128)
	114: MutBorrowLoc[21](storage_fund_reward: Balance<SUI>)
	115: CopyLoc[20](storage_fund_reinvestment_amount: u128)
	116: CastU64
	117: Call balance::split<SUI>(&mut Balance<SUI>, u64): Balance<SUI>
	118: StLoc[19](storage_fund_reinvestment: Balance<SUI>)
	119: CopyLoc[0](self: &mut SuiSystemState)
	120: MutBorrowField[2](SuiSystemState.storage_fund: Balance<SUI>)
	121: MoveLoc[19](storage_fund_reinvestment: Balance<SUI>)
	122: Call balance::join<SUI>(&mut Balance<SUI>, Balance<SUI>): u64
	123: Pop
	124: CopyLoc[0](self: &mut SuiSystemState)
	125: ImmBorrowField[5](SuiSystemState.epoch: u64)
	126: ReadRef
	127: LdU64(1)
	128: Add
	129: CopyLoc[0](self: &mut SuiSystemState)
	130: MutBorrowField[5](SuiSystemState.epoch: u64)
	131: WriteRef
	132: CopyLoc[1](new_epoch: u64)
	133: CopyLoc[0](self: &mut SuiSystemState)
	134: ImmBorrowField[5](SuiSystemState.epoch: u64)
	135: ReadRef
	136: Eq
	137: BrFalse(139)
B10:
	138: Branch(145)
B11:
	139: MoveLoc[0](self: &mut SuiSystemState)
	140: Pop
	141: MoveLoc[9](ctx: &mut TxContext)
	142: Pop
	143: LdU64(0)
	144: Abort
B12:
	145: ImmBorrowLoc[13](computation_reward: Balance<SUI>)
	146: Call balance::value<SUI>(&Balance<SUI>): u64
	147: ImmBorrowLoc[21](storage_fund_reward: Balance<SUI>)
	148: Call balance::value<SUI>(&Balance<SUI>): u64
	149: Add
	150: StLoc[24](total_rewards_amount: u64)
	151: MoveLoc[1](new_epoch: u64)
	152: CopyLoc[0](self: &mut SuiSystemState)
	153: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	154: MutBorrowLoc[13](computation_reward: Balance<SUI>)
	155: MutBorrowLoc[21](storage_fund_reward: Balance<SUI>)
	156: CopyLoc[0](self: &mut SuiSystemState)
	157: ImmBorrowField[6](SuiSystemState.validator_report_records: VecMap<address, VecSet<address>>)
	158: ReadRef
	159: MoveLoc[6](reward_slashing_rate: u64)
	160: MoveLoc[9](ctx: &mut TxContext)
	161: Call validator_set::advance_epoch(u64, &mut ValidatorSet, &mut Balance<SUI>, &mut Balance<SUI>, VecMap<address, VecSet<address>>, u64, &mut TxContext)
	162: CopyLoc[0](self: &mut SuiSystemState)
	163: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	164: Call validator_set::derive_reference_gas_price(&ValidatorSet): u64
	165: CopyLoc[0](self: &mut SuiSystemState)
	166: MutBorrowField[7](SuiSystemState.reference_gas_price: u64)
	167: WriteRef
	168: CopyLoc[0](self: &mut SuiSystemState)
	169: MutBorrowField[2](SuiSystemState.storage_fund: Balance<SUI>)
	170: MoveLoc[21](storage_fund_reward: Balance<SUI>)
	171: Call balance::join<SUI>(&mut Balance<SUI>, Balance<SUI>): u64
	172: Pop
	173: CopyLoc[0](self: &mut SuiSystemState)
	174: MutBorrowField[2](SuiSystemState.storage_fund: Balance<SUI>)
	175: MoveLoc[13](computation_reward: Balance<SUI>)
	176: Call balance::join<SUI>(&mut Balance<SUI>, Balance<SUI>): u64
	177: Pop
	178: CopyLoc[0](self: &mut SuiSystemState)
	179: ImmBorrowField[2](SuiSystemState.storage_fund: Balance<SUI>)
	180: Call balance::value<SUI>(&Balance<SUI>): u64
	181: CopyLoc[4](storage_rebate: u64)
	182: Ge
	183: BrFalse(185)
B13:
	184: Branch(189)
B14:
	185: MoveLoc[0](self: &mut SuiSystemState)
	186: Pop
	187: LdU64(0)
	188: Abort
B15:
	189: CopyLoc[0](self: &mut SuiSystemState)
	190: MutBorrowField[2](SuiSystemState.storage_fund: Balance<SUI>)
	191: CopyLoc[4](storage_rebate: u64)
	192: Call balance::split<SUI>(&mut Balance<SUI>, u64): Balance<SUI>
	193: Call balance::destroy_storage_rebates<SUI>(Balance<SUI>)
	194: Call vec_map::empty<address, VecSet<address>>(): VecMap<address, VecSet<address>>
	195: CopyLoc[0](self: &mut SuiSystemState)
	196: MutBorrowField[6](SuiSystemState.validator_report_records: VecMap<address, VecSet<address>>)
	197: WriteRef
	198: CopyLoc[0](self: &mut SuiSystemState)
	199: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	200: Call validator_set::total_delegation_stake(&ValidatorSet): u64
	201: CopyLoc[0](self: &mut SuiSystemState)
	202: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	203: Call validator_set::total_validator_stake(&ValidatorSet): u64
	204: Add
	205: StLoc[15](new_total_stake: u64)
	206: CopyLoc[0](self: &mut SuiSystemState)
	207: ImmBorrowField[5](SuiSystemState.epoch: u64)
	208: ReadRef
	209: CopyLoc[0](self: &mut SuiSystemState)
	210: ImmBorrowField[7](SuiSystemState.reference_gas_price: u64)
	211: ReadRef
	212: MoveLoc[15](new_total_stake: u64)
	213: MoveLoc[2](storage_charge: u64)
	214: MoveLoc[20](storage_fund_reinvestment_amount: u128)
	215: CastU64
	216: Add
	217: MoveLoc[4](storage_rebate: u64)
	218: CopyLoc[0](self: &mut SuiSystemState)
	219: ImmBorrowField[2](SuiSystemState.storage_fund: Balance<SUI>)
	220: Call balance::value<SUI>(&Balance<SUI>): u64
	221: MoveLoc[17](stake_subsidy_amount: u64)
	222: MoveLoc[3](computation_charge: u64)
	223: MoveLoc[24](total_rewards_amount: u64)
	224: Pack[1](SystemEpochInfo)
	225: Call event::emit<SystemEpochInfo>(SystemEpochInfo)
	226: LdFalse
	227: MoveLoc[0](self: &mut SuiSystemState)
	228: MutBorrowField[8](SuiSystemState.safe_mode: bool)
	229: WriteRef
	230: Ret
}
entry public advance_epoch_safe_mode(self: &mut SuiSystemState, new_epoch: u64, ctx: &mut TxContext) {
B0:
	0: MoveLoc[2](ctx: &mut TxContext)
	1: FreezeRef
	2: Call tx_context::sender(&TxContext): address
	3: LdConst[8](Address: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
	4: Eq
	5: BrFalse(7)
B1:
	6: Branch(11)
B2:
	7: MoveLoc[0](self: &mut SuiSystemState)
	8: Pop
	9: LdU64(0)
	10: Abort
B3:
	11: MoveLoc[1](new_epoch: u64)
	12: CopyLoc[0](self: &mut SuiSystemState)
	13: MutBorrowField[5](SuiSystemState.epoch: u64)
	14: WriteRef
	15: LdTrue
	16: MoveLoc[0](self: &mut SuiSystemState)
	17: MutBorrowField[8](SuiSystemState.safe_mode: bool)
	18: WriteRef
	19: Ret
}
entry public cancel_delegation_request(self: &mut SuiSystemState, staked_sui: StakedSui, ctx: &mut TxContext) {
B0:
	0: ImmBorrowLoc[1](staked_sui: StakedSui)
	1: Call staking_pool::delegation_request_epoch(&StakedSui): u64
	2: CopyLoc[0](self: &mut SuiSystemState)
	3: ImmBorrowField[5](SuiSystemState.epoch: u64)
	4: ReadRef
	5: Eq
	6: BrFalse(8)
B1:
	7: Branch(14)
B2:
	8: MoveLoc[0](self: &mut SuiSystemState)
	9: Pop
	10: MoveLoc[2](ctx: &mut TxContext)
	11: Pop
	12: LdConst[7](U64: [6, 0, 0, 0, 0, 0, 0, 0])
	13: Abort
B3:
	14: MoveLoc[0](self: &mut SuiSystemState)
	15: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	16: MoveLoc[1](staked_sui: StakedSui)
	17: MoveLoc[2](ctx: &mut TxContext)
	18: Call validator_set::cancel_delegation_request(&mut ValidatorSet, StakedSui, &mut TxContext)
	19: Ret
}
public(friend) create(validators: vector<Validator>, sui_supply: Supply<SUI>, storage_fund: Balance<SUI>, max_validator_candidate_count: u64, min_validator_stake: u64, initial_stake_subsidy_amount: u64, epoch_start_timestamp_ms: u64) {
B0:
	0: MoveLoc[0](validators: vector<Validator>)
	1: Call validator_set::new(vector<Validator>): ValidatorSet
	2: StLoc[8](validators#1: ValidatorSet)
	3: ImmBorrowLoc[8](validators#1: ValidatorSet)
	4: Call validator_set::derive_reference_gas_price(&ValidatorSet): u64
	5: StLoc[7](reference_gas_price: u64)
	6: Call object::sui_system_state(): UID
	7: LdU64(0)
	8: MoveLoc[8](validators#1: ValidatorSet)
	9: MoveLoc[1](sui_supply: Supply<SUI>)
	10: MoveLoc[2](storage_fund: Balance<SUI>)
	11: MoveLoc[4](min_validator_stake: u64)
	12: MoveLoc[3](max_validator_candidate_count: u64)
	13: Pack[2](SystemParameters)
	14: MoveLoc[7](reference_gas_price: u64)
	15: Call vec_map::empty<address, VecSet<address>>(): VecMap<address, VecSet<address>>
	16: MoveLoc[5](initial_stake_subsidy_amount: u64)
	17: Call stake_subsidy::create(u64): StakeSubsidy
	18: LdFalse
	19: MoveLoc[6](epoch_start_timestamp_ms: u64)
	20: Pack[0](SuiSystemState)
	21: Call transfer::share_object<SuiSystemState>(SuiSystemState)
	22: Ret
}
public epoch(self: &SuiSystemState): u64 {
B0:
	0: MoveLoc[0](self: &SuiSystemState)
	1: ImmBorrowField[5](SuiSystemState.epoch: u64)
	2: ReadRef
	3: Ret
}
public epoch_start_timestamp_ms(self: &SuiSystemState): u64 {
B0:
	0: MoveLoc[0](self: &SuiSystemState)
	1: ImmBorrowField[0](SuiSystemState.epoch_start_timestamp_ms: u64)
	2: ReadRef
	3: Ret
}
extract_coin_balance(coins: vector<Coin<SUI>>, amount: Option<u64>, ctx: &mut TxContext): Balance<SUI> {
L0:	merged_coin: Coin<SUI>
L1:	total_balance: Balance<SUI>
B0:
	0: MutBorrowLoc[0](coins: vector<Coin<SUI>>)
	1: VecPopBack(50)
	2: StLoc[6](merged_coin: Coin<SUI>)
	3: MutBorrowLoc[6](merged_coin: Coin<SUI>)
	4: MoveLoc[0](coins: vector<Coin<SUI>>)
	5: Call pay::join_vec<SUI>(&mut Coin<SUI>, vector<Coin<SUI>>)
	6: MoveLoc[6](merged_coin: Coin<SUI>)
	7: Call coin::into_balance<SUI>(Coin<SUI>): Balance<SUI>
	8: StLoc[7](total_balance: Balance<SUI>)
	9: ImmBorrowLoc[1](amount: Option<u64>)
	10: Call option::is_some<u64>(&Option<u64>): bool
	11: BrFalse(39)
B1:
	12: MoveLoc[1](amount: Option<u64>)
	13: Call option::destroy_some<u64>(Option<u64>): u64
	14: StLoc[4](amount#1: u64)
	15: MutBorrowLoc[7](total_balance: Balance<SUI>)
	16: MoveLoc[4](amount#1: u64)
	17: Call balance::split<SUI>(&mut Balance<SUI>, u64): Balance<SUI>
	18: StLoc[5](balance: Balance<SUI>)
	19: ImmBorrowLoc[7](total_balance: Balance<SUI>)
	20: Call balance::value<SUI>(&Balance<SUI>): u64
	21: LdU64(0)
	22: Gt
	23: BrFalse(32)
B2:
	24: MoveLoc[7](total_balance: Balance<SUI>)
	25: CopyLoc[2](ctx: &mut TxContext)
	26: Call coin::from_balance<SUI>(Balance<SUI>, &mut TxContext): Coin<SUI>
	27: MoveLoc[2](ctx: &mut TxContext)
	28: FreezeRef
	29: Call tx_context::sender(&TxContext): address
	30: Call transfer::transfer<Coin<SUI>>(Coin<SUI>, address)
	31: Branch(36)
B3:
	32: MoveLoc[2](ctx: &mut TxContext)
	33: Pop
	34: MoveLoc[7](total_balance: Balance<SUI>)
	35: Call balance::destroy_zero<SUI>(Balance<SUI>)
B4:
	36: MoveLoc[5](balance: Balance<SUI>)
	37: StLoc[3](%#2: Balance<SUI>)
	38: Branch(43)
B5:
	39: MoveLoc[2](ctx: &mut TxContext)
	40: Pop
	41: MoveLoc[7](total_balance: Balance<SUI>)
	42: StLoc[3](%#2: Balance<SUI>)
B6:
	43: MoveLoc[3](%#2: Balance<SUI>)
	44: Ret
}
extract_locked_coin_balance(coins: vector<LockedCoin<SUI>>, amount: Option<u64>, ctx: &mut TxContext): Balance<SUI> * EpochTimeLock {
L0:	balance: Balance<SUI>
L1:	balance#2: Balance<SUI>
L2:	first_lock: EpochTimeLock
L3:	i: u64
L4:	len: u64
L5:	lock: EpochTimeLock
L6:	total_balance: Balance<SUI>
B0:
	0: MutBorrowLoc[0](coins: vector<LockedCoin<SUI>>)
	1: VecPopBack(59)
	2: Call locked_coin::into_balance<SUI>(LockedCoin<SUI>): Balance<SUI> * EpochTimeLock
	3: StLoc[8](first_lock: EpochTimeLock)
	4: StLoc[12](total_balance: Balance<SUI>)
	5: LdU64(0)
	6: ImmBorrowLoc[0](coins: vector<LockedCoin<SUI>>)
	7: VecLen(59)
	8: StLoc[10](len: u64)
	9: StLoc[9](i: u64)
B1:
	10: CopyLoc[9](i: u64)
	11: CopyLoc[10](len: u64)
	12: Lt
	13: BrFalse(42)
B2:
	14: Branch(15)
B3:
	15: MutBorrowLoc[0](coins: vector<LockedCoin<SUI>>)
	16: VecPopBack(59)
	17: Call locked_coin::into_balance<SUI>(LockedCoin<SUI>): Balance<SUI> * EpochTimeLock
	18: StLoc[11](lock: EpochTimeLock)
	19: StLoc[6](balance: Balance<SUI>)
	20: ImmBorrowLoc[11](lock: EpochTimeLock)
	21: Call epoch_time_lock::epoch(&EpochTimeLock): u64
	22: ImmBorrowLoc[8](first_lock: EpochTimeLock)
	23: Call epoch_time_lock::epoch(&EpochTimeLock): u64
	24: Eq
	25: BrFalse(27)
B4:
	26: Branch(31)
B5:
	27: MoveLoc[2](ctx: &mut TxContext)
	28: Pop
	29: LdU64(0)
	30: Abort
B6:
	31: MoveLoc[11](lock: EpochTimeLock)
	32: Call epoch_time_lock::destroy_unchecked(EpochTimeLock)
	33: MutBorrowLoc[12](total_balance: Balance<SUI>)
	34: MoveLoc[6](balance: Balance<SUI>)
	35: Call balance::join<SUI>(&mut Balance<SUI>, Balance<SUI>): u64
	36: Pop
	37: MoveLoc[9](i: u64)
	38: LdU64(1)
	39: Add
	40: StLoc[9](i: u64)
	41: Branch(10)
B7:
	42: MoveLoc[0](coins: vector<LockedCoin<SUI>>)
	43: VecUnpack(59, 0)
	44: ImmBorrowLoc[1](amount: Option<u64>)
	45: Call option::is_some<u64>(&Option<u64>): bool
	46: BrFalse(76)
B8:
	47: MoveLoc[1](amount: Option<u64>)
	48: Call option::destroy_some<u64>(Option<u64>): u64
	49: StLoc[5](amount#1: u64)
	50: MutBorrowLoc[12](total_balance: Balance<SUI>)
	51: MoveLoc[5](amount#1: u64)
	52: Call balance::split<SUI>(&mut Balance<SUI>, u64): Balance<SUI>
	53: StLoc[7](balance#2: Balance<SUI>)
	54: ImmBorrowLoc[12](total_balance: Balance<SUI>)
	55: Call balance::value<SUI>(&Balance<SUI>): u64
	56: LdU64(0)
	57: Gt
	58: BrFalse(67)
B9:
	59: MoveLoc[12](total_balance: Balance<SUI>)
	60: CopyLoc[8](first_lock: EpochTimeLock)
	61: CopyLoc[2](ctx: &mut TxContext)
	62: FreezeRef
	63: Call tx_context::sender(&TxContext): address
	64: MoveLoc[2](ctx: &mut TxContext)
	65: Call locked_coin::new_from_balance<SUI>(Balance<SUI>, EpochTimeLock, address, &mut TxContext)
	66: Branch(71)
B10:
	67: MoveLoc[2](ctx: &mut TxContext)
	68: Pop
	69: MoveLoc[12](total_balance: Balance<SUI>)
	70: Call balance::destroy_zero<SUI>(Balance<SUI>)
B11:
	71: MoveLoc[7](balance#2: Balance<SUI>)
	72: MoveLoc[8](first_lock: EpochTimeLock)
	73: StLoc[4](%#4: EpochTimeLock)
	74: StLoc[3](%#3: Balance<SUI>)
	75: Branch(82)
B12:
	76: MoveLoc[2](ctx: &mut TxContext)
	77: Pop
	78: MoveLoc[12](total_balance: Balance<SUI>)
	79: MoveLoc[8](first_lock: EpochTimeLock)
	80: StLoc[4](%#4: EpochTimeLock)
	81: StLoc[3](%#3: Balance<SUI>)
B13:
	82: MoveLoc[3](%#3: Balance<SUI>)
	83: MoveLoc[4](%#4: EpochTimeLock)
	84: Ret
}
public get_reporters_of(self: &SuiSystemState, addr: address): VecSet<address> {
B0:
	0: CopyLoc[0](self: &SuiSystemState)
	1: ImmBorrowField[6](SuiSystemState.validator_report_records: VecMap<address, VecSet<address>>)
	2: ImmBorrowLoc[1](addr: address)
	3: Call vec_map::contains<address, VecSet<address>>(&VecMap<address, VecSet<address>>, &address): bool
	4: BrFalse(12)
B1:
	5: MoveLoc[0](self: &SuiSystemState)
	6: ImmBorrowField[6](SuiSystemState.validator_report_records: VecMap<address, VecSet<address>>)
	7: ImmBorrowLoc[1](addr: address)
	8: Call vec_map::get<address, VecSet<address>>(&VecMap<address, VecSet<address>>, &address): &VecSet<address>
	9: ReadRef
	10: StLoc[2](%#1: VecSet<address>)
	11: Branch(16)
B2:
	12: MoveLoc[0](self: &SuiSystemState)
	13: Pop
	14: Call vec_set::empty<address>(): VecSet<address>
	15: StLoc[2](%#1: VecSet<address>)
B3:
	16: MoveLoc[2](%#1: VecSet<address>)
	17: Ret
}
entry public report_validator(self: &mut SuiSystemState, validator_addr: address, ctx: &TxContext) {
B0:
	0: MoveLoc[2](ctx: &TxContext)
	1: Call tx_context::sender(&TxContext): address
	2: StLoc[5](sender: address)
	3: CopyLoc[0](self: &mut SuiSystemState)
	4: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	5: CopyLoc[5](sender: address)
	6: Call validator_set::is_active_validator(&ValidatorSet, address): bool
	7: BrFalse(9)
B1:
	8: Branch(13)
B2:
	9: MoveLoc[0](self: &mut SuiSystemState)
	10: Pop
	11: LdConst[5](U64: [0, 0, 0, 0, 0, 0, 0, 0])
	12: Abort
B3:
	13: CopyLoc[0](self: &mut SuiSystemState)
	14: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	15: CopyLoc[1](validator_addr: address)
	16: Call validator_set::is_active_validator(&ValidatorSet, address): bool
	17: BrFalse(19)
B4:
	18: Branch(23)
B5:
	19: MoveLoc[0](self: &mut SuiSystemState)
	20: Pop
	21: LdConst[5](U64: [0, 0, 0, 0, 0, 0, 0, 0])
	22: Abort
B6:
	23: CopyLoc[5](sender: address)
	24: CopyLoc[1](validator_addr: address)
	25: Neq
	26: BrFalse(28)
B7:
	27: Branch(32)
B8:
	28: MoveLoc[0](self: &mut SuiSystemState)
	29: Pop
	30: LdConst[2](U64: [3, 0, 0, 0, 0, 0, 0, 0])
	31: Abort
B9:
	32: CopyLoc[0](self: &mut SuiSystemState)
	33: ImmBorrowField[6](SuiSystemState.validator_report_records: VecMap<address, VecSet<address>>)
	34: ImmBorrowLoc[1](validator_addr: address)
	35: Call vec_map::contains<address, VecSet<address>>(&VecMap<address, VecSet<address>>, &address): bool
	36: Not
	37: BrFalse(45)
B10:
	38: MoveLoc[0](self: &mut SuiSystemState)
	39: MutBorrowField[6](SuiSystemState.validator_report_records: VecMap<address, VecSet<address>>)
	40: MoveLoc[1](validator_addr: address)
	41: MoveLoc[5](sender: address)
	42: Call vec_set::singleton<address>(address): VecSet<address>
	43: Call vec_map::insert<address, VecSet<address>>(&mut VecMap<address, VecSet<address>>, address, VecSet<address>)
	44: Branch(64)
B11:
	45: MoveLoc[0](self: &mut SuiSystemState)
	46: MutBorrowField[6](SuiSystemState.validator_report_records: VecMap<address, VecSet<address>>)
	47: ImmBorrowLoc[1](validator_addr: address)
	48: Call vec_map::get_mut<address, VecSet<address>>(&mut VecMap<address, VecSet<address>>, &address): &mut VecSet<address>
	49: StLoc[4](reporters: &mut VecSet<address>)
	50: CopyLoc[4](reporters: &mut VecSet<address>)
	51: ImmBorrowLoc[5](sender: address)
	52: StLoc[3](%#2: &address)
	53: FreezeRef
	54: MoveLoc[3](%#2: &address)
	55: Call vec_set::contains<address>(&VecSet<address>, &address): bool
	56: Not
	57: BrFalse(62)
B12:
	58: MoveLoc[4](reporters: &mut VecSet<address>)
	59: MoveLoc[5](sender: address)
	60: Call vec_set::insert<address>(&mut VecSet<address>, address)
	61: Branch(64)
B13:
	62: MoveLoc[4](reporters: &mut VecSet<address>)
	63: Pop
B14:
	64: Ret
}
entry public request_add_delegation(self: &mut SuiSystemState, delegate_stake: Coin<SUI>, validator_address: address, ctx: &mut TxContext) {
B0:
	0: MoveLoc[0](self: &mut SuiSystemState)
	1: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: MoveLoc[2](validator_address: address)
	3: MoveLoc[1](delegate_stake: Coin<SUI>)
	4: Call coin::into_balance<SUI>(Coin<SUI>): Balance<SUI>
	5: Call option::none<EpochTimeLock>(): Option<EpochTimeLock>
	6: MoveLoc[3](ctx: &mut TxContext)
	7: Call validator_set::request_add_delegation(&mut ValidatorSet, address, Balance<SUI>, Option<EpochTimeLock>, &mut TxContext)
	8: Ret
}
entry public request_add_delegation_mul_coin(self: &mut SuiSystemState, delegate_stakes: vector<Coin<SUI>>, stake_amount: Option<u64>, validator_address: address, ctx: &mut TxContext) {
B0:
	0: MoveLoc[1](delegate_stakes: vector<Coin<SUI>>)
	1: MoveLoc[2](stake_amount: Option<u64>)
	2: CopyLoc[4](ctx: &mut TxContext)
	3: Call extract_coin_balance(vector<Coin<SUI>>, Option<u64>, &mut TxContext): Balance<SUI>
	4: StLoc[5](balance: Balance<SUI>)
	5: MoveLoc[0](self: &mut SuiSystemState)
	6: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	7: MoveLoc[3](validator_address: address)
	8: MoveLoc[5](balance: Balance<SUI>)
	9: Call option::none<EpochTimeLock>(): Option<EpochTimeLock>
	10: MoveLoc[4](ctx: &mut TxContext)
	11: Call validator_set::request_add_delegation(&mut ValidatorSet, address, Balance<SUI>, Option<EpochTimeLock>, &mut TxContext)
	12: Ret
}
entry public request_add_delegation_mul_locked_coin(self: &mut SuiSystemState, delegate_stakes: vector<LockedCoin<SUI>>, stake_amount: Option<u64>, validator_address: address, ctx: &mut TxContext) {
B0:
	0: MoveLoc[1](delegate_stakes: vector<LockedCoin<SUI>>)
	1: MoveLoc[2](stake_amount: Option<u64>)
	2: CopyLoc[4](ctx: &mut TxContext)
	3: Call extract_locked_coin_balance(vector<LockedCoin<SUI>>, Option<u64>, &mut TxContext): Balance<SUI> * EpochTimeLock
	4: StLoc[6](lock: EpochTimeLock)
	5: StLoc[5](balance: Balance<SUI>)
	6: MoveLoc[0](self: &mut SuiSystemState)
	7: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	8: MoveLoc[3](validator_address: address)
	9: MoveLoc[5](balance: Balance<SUI>)
	10: MoveLoc[6](lock: EpochTimeLock)
	11: Call option::some<EpochTimeLock>(EpochTimeLock): Option<EpochTimeLock>
	12: MoveLoc[4](ctx: &mut TxContext)
	13: Call validator_set::request_add_delegation(&mut ValidatorSet, address, Balance<SUI>, Option<EpochTimeLock>, &mut TxContext)
	14: Ret
}
entry public request_add_delegation_with_locked_coin(self: &mut SuiSystemState, delegate_stake: LockedCoin<SUI>, validator_address: address, ctx: &mut TxContext) {
B0:
	0: MoveLoc[1](delegate_stake: LockedCoin<SUI>)
	1: Call locked_coin::into_balance<SUI>(LockedCoin<SUI>): Balance<SUI> * EpochTimeLock
	2: StLoc[5](lock: EpochTimeLock)
	3: StLoc[4](balance: Balance<SUI>)
	4: MoveLoc[0](self: &mut SuiSystemState)
	5: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	6: MoveLoc[2](validator_address: address)
	7: MoveLoc[4](balance: Balance<SUI>)
	8: MoveLoc[5](lock: EpochTimeLock)
	9: Call option::some<EpochTimeLock>(EpochTimeLock): Option<EpochTimeLock>
	10: MoveLoc[3](ctx: &mut TxContext)
	11: Call validator_set::request_add_delegation(&mut ValidatorSet, address, Balance<SUI>, Option<EpochTimeLock>, &mut TxContext)
	12: Ret
}
entry public request_add_stake(self: &mut SuiSystemState, new_stake: Coin<SUI>, ctx: &mut TxContext) {
B0:
	0: MoveLoc[0](self: &mut SuiSystemState)
	1: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: MoveLoc[1](new_stake: Coin<SUI>)
	3: Call coin::into_balance<SUI>(Coin<SUI>): Balance<SUI>
	4: Call option::none<EpochTimeLock>(): Option<EpochTimeLock>
	5: MoveLoc[2](ctx: &mut TxContext)
	6: Call validator_set::request_add_stake(&mut ValidatorSet, Balance<SUI>, Option<EpochTimeLock>, &mut TxContext)
	7: Ret
}
entry public request_add_stake_with_locked_coin(self: &mut SuiSystemState, new_stake: LockedCoin<SUI>, ctx: &mut TxContext) {
B0:
	0: MoveLoc[1](new_stake: LockedCoin<SUI>)
	1: Call locked_coin::into_balance<SUI>(LockedCoin<SUI>): Balance<SUI> * EpochTimeLock
	2: StLoc[4](epoch_time_lock: EpochTimeLock)
	3: StLoc[3](balance: Balance<SUI>)
	4: MoveLoc[0](self: &mut SuiSystemState)
	5: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	6: MoveLoc[3](balance: Balance<SUI>)
	7: MoveLoc[4](epoch_time_lock: EpochTimeLock)
	8: Call option::some<EpochTimeLock>(EpochTimeLock): Option<EpochTimeLock>
	9: MoveLoc[2](ctx: &mut TxContext)
	10: Call validator_set::request_add_stake(&mut ValidatorSet, Balance<SUI>, Option<EpochTimeLock>, &mut TxContext)
	11: Ret
}
entry public request_add_validator(self: &mut SuiSystemState, pubkey_bytes: vector<u8>, network_pubkey_bytes: vector<u8>, worker_pubkey_bytes: vector<u8>, proof_of_possession: vector<u8>, name: vector<u8>, description: vector<u8>, image_url: vector<u8>, project_url: vector<u8>, net_address: vector<u8>, consensus_address: vector<u8>, worker_address: vector<u8>, stake: Coin<SUI>, gas_price: u64, commission_rate: u64, ctx: &mut TxContext) {
B0:
	0: CopyLoc[0](self: &mut SuiSystemState)
	1: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: Call validator_set::next_epoch_validator_count(&ValidatorSet): u64
	3: CopyLoc[0](self: &mut SuiSystemState)
	4: ImmBorrowField[9](SuiSystemState.parameters: SystemParameters)
	5: ImmBorrowField[10](SystemParameters.max_validator_candidate_count: u64)
	6: ReadRef
	7: Lt
	8: BrFalse(10)
B1:
	9: Branch(16)
B2:
	10: MoveLoc[0](self: &mut SuiSystemState)
	11: Pop
	12: MoveLoc[15](ctx: &mut TxContext)
	13: Pop
	14: LdConst[4](U64: [1, 0, 0, 0, 0, 0, 0, 0])
	15: Abort
B3:
	16: ImmBorrowLoc[12](stake: Coin<SUI>)
	17: Call coin::value<SUI>(&Coin<SUI>): u64
	18: CopyLoc[0](self: &mut SuiSystemState)
	19: ImmBorrowField[9](SuiSystemState.parameters: SystemParameters)
	20: ImmBorrowField[11](SystemParameters.min_validator_stake: u64)
	21: ReadRef
	22: Ge
	23: BrFalse(25)
B4:
	24: Branch(31)
B5:
	25: MoveLoc[0](self: &mut SuiSystemState)
	26: Pop
	27: MoveLoc[15](ctx: &mut TxContext)
	28: Pop
	29: LdConst[4](U64: [1, 0, 0, 0, 0, 0, 0, 0])
	30: Abort
B6:
	31: CopyLoc[15](ctx: &mut TxContext)
	32: FreezeRef
	33: Call tx_context::sender(&TxContext): address
	34: MoveLoc[1](pubkey_bytes: vector<u8>)
	35: MoveLoc[2](network_pubkey_bytes: vector<u8>)
	36: MoveLoc[3](worker_pubkey_bytes: vector<u8>)
	37: MoveLoc[4](proof_of_possession: vector<u8>)
	38: MoveLoc[5](name: vector<u8>)
	39: MoveLoc[6](description: vector<u8>)
	40: MoveLoc[7](image_url: vector<u8>)
	41: MoveLoc[8](project_url: vector<u8>)
	42: MoveLoc[9](net_address: vector<u8>)
	43: MoveLoc[10](consensus_address: vector<u8>)
	44: MoveLoc[11](worker_address: vector<u8>)
	45: MoveLoc[12](stake: Coin<SUI>)
	46: Call coin::into_balance<SUI>(Coin<SUI>): Balance<SUI>
	47: Call option::none<EpochTimeLock>(): Option<EpochTimeLock>
	48: MoveLoc[13](gas_price: u64)
	49: MoveLoc[14](commission_rate: u64)
	50: MoveLoc[15](ctx: &mut TxContext)
	51: Call validator::new(address, vector<u8>, vector<u8>, vector<u8>, vector<u8>, vector<u8>, vector<u8>, vector<u8>, vector<u8>, vector<u8>, vector<u8>, vector<u8>, Balance<SUI>, Option<EpochTimeLock>, u64, u64, &mut TxContext): Validator
	52: StLoc[16](validator: Validator)
	53: MoveLoc[0](self: &mut SuiSystemState)
	54: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	55: MoveLoc[16](validator: Validator)
	56: Call validator_set::request_add_validator(&mut ValidatorSet, Validator)
	57: Ret
}
entry public request_remove_validator(self: &mut SuiSystemState, ctx: &mut TxContext) {
B0:
	0: MoveLoc[0](self: &mut SuiSystemState)
	1: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: MoveLoc[1](ctx: &mut TxContext)
	3: FreezeRef
	4: Call validator_set::request_remove_validator(&mut ValidatorSet, &TxContext)
	5: Ret
}
entry public request_set_commission_rate(self: &mut SuiSystemState, new_commission_rate: u64, ctx: &mut TxContext) {
B0:
	0: MoveLoc[0](self: &mut SuiSystemState)
	1: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: MoveLoc[1](new_commission_rate: u64)
	3: MoveLoc[2](ctx: &mut TxContext)
	4: FreezeRef
	5: Call validator_set::request_set_commission_rate(&mut ValidatorSet, u64, &TxContext)
	6: Ret
}
entry public request_set_gas_price(self: &mut SuiSystemState, new_gas_price: u64, ctx: &mut TxContext) {
B0:
	0: MoveLoc[0](self: &mut SuiSystemState)
	1: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: MoveLoc[1](new_gas_price: u64)
	3: MoveLoc[2](ctx: &mut TxContext)
	4: FreezeRef
	5: Call validator_set::request_set_gas_price(&mut ValidatorSet, u64, &TxContext)
	6: Ret
}
entry public request_switch_delegation(self: &mut SuiSystemState, delegation: Delegation, staked_sui: StakedSui, new_validator_address: address, ctx: &mut TxContext) {
B0:
	0: MoveLoc[0](self: &mut SuiSystemState)
	1: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: MoveLoc[1](delegation: Delegation)
	3: MoveLoc[2](staked_sui: StakedSui)
	4: MoveLoc[3](new_validator_address: address)
	5: MoveLoc[4](ctx: &mut TxContext)
	6: Call validator_set::request_switch_delegation(&mut ValidatorSet, Delegation, StakedSui, address, &mut TxContext)
	7: Ret
}
entry public request_withdraw_delegation(self: &mut SuiSystemState, delegation: Delegation, staked_sui: StakedSui, ctx: &mut TxContext) {
B0:
	0: MoveLoc[0](self: &mut SuiSystemState)
	1: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: MoveLoc[1](delegation: Delegation)
	3: MoveLoc[2](staked_sui: StakedSui)
	4: MoveLoc[3](ctx: &mut TxContext)
	5: Call validator_set::request_withdraw_delegation(&mut ValidatorSet, Delegation, StakedSui, &mut TxContext)
	6: Ret
}
entry public request_withdraw_stake(self: &mut SuiSystemState, stake: &mut Stake, withdraw_amount: u64, ctx: &mut TxContext) {
B0:
	0: CopyLoc[0](self: &mut SuiSystemState)
	1: MutBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: MoveLoc[1](stake: &mut Stake)
	3: MoveLoc[2](withdraw_amount: u64)
	4: MoveLoc[0](self: &mut SuiSystemState)
	5: ImmBorrowField[9](SuiSystemState.parameters: SystemParameters)
	6: ImmBorrowField[11](SystemParameters.min_validator_stake: u64)
	7: ReadRef
	8: MoveLoc[3](ctx: &mut TxContext)
	9: Call validator_set::request_withdraw_stake(&mut ValidatorSet, &mut Stake, u64, u64, &mut TxContext)
	10: Ret
}
entry public undo_report_validator(self: &mut SuiSystemState, validator_addr: address, ctx: &TxContext) {
B0:
	0: MoveLoc[2](ctx: &TxContext)
	1: Call tx_context::sender(&TxContext): address
	2: StLoc[5](sender: address)
	3: CopyLoc[0](self: &mut SuiSystemState)
	4: ImmBorrowField[6](SuiSystemState.validator_report_records: VecMap<address, VecSet<address>>)
	5: ImmBorrowLoc[1](validator_addr: address)
	6: Call vec_map::contains<address, VecSet<address>>(&VecMap<address, VecSet<address>>, &address): bool
	7: BrFalse(9)
B1:
	8: Branch(13)
B2:
	9: MoveLoc[0](self: &mut SuiSystemState)
	10: Pop
	11: LdConst[6](U64: [4, 0, 0, 0, 0, 0, 0, 0])
	12: Abort
B3:
	13: MoveLoc[0](self: &mut SuiSystemState)
	14: MutBorrowField[6](SuiSystemState.validator_report_records: VecMap<address, VecSet<address>>)
	15: ImmBorrowLoc[1](validator_addr: address)
	16: Call vec_map::get_mut<address, VecSet<address>>(&mut VecMap<address, VecSet<address>>, &address): &mut VecSet<address>
	17: StLoc[4](reporters: &mut VecSet<address>)
	18: CopyLoc[4](reporters: &mut VecSet<address>)
	19: ImmBorrowLoc[5](sender: address)
	20: StLoc[3](%#2: &address)
	21: FreezeRef
	22: MoveLoc[3](%#2: &address)
	23: Call vec_set::contains<address>(&VecSet<address>, &address): bool
	24: BrFalse(26)
B4:
	25: Branch(30)
B5:
	26: MoveLoc[4](reporters: &mut VecSet<address>)
	27: Pop
	28: LdConst[6](U64: [4, 0, 0, 0, 0, 0, 0, 0])
	29: Abort
B6:
	30: MoveLoc[4](reporters: &mut VecSet<address>)
	31: ImmBorrowLoc[5](sender: address)
	32: Call vec_set::remove<address>(&mut VecSet<address>, &address)
	33: Ret
}
public validator_delegate_amount(self: &SuiSystemState, validator_addr: address): u64 {
B0:
	0: MoveLoc[0](self: &SuiSystemState)
	1: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: MoveLoc[1](validator_addr: address)
	3: Call validator_set::validator_delegate_amount(&ValidatorSet, address): u64
	4: Ret
}
public validator_stake_amount(self: &SuiSystemState, validator_addr: address): u64 {
B0:
	0: MoveLoc[0](self: &SuiSystemState)
	1: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: MoveLoc[1](validator_addr: address)
	3: Call validator_set::validator_stake_amount(&ValidatorSet, address): u64
	4: Ret
}
public validators(self: &SuiSystemState): &ValidatorSet {
B0:
	0: MoveLoc[0](self: &SuiSystemState)
	1: ImmBorrowField[1](SuiSystemState.validators: ValidatorSet)
	2: Ret
}
}
