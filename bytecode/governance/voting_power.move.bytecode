// Move bytecode v6
module 2.voting_power {
use 0000000000000000000000000000000000000001::vector;
use 0000000000000000000000000000000000000002::math;
use 0000000000000000000000000000000000000002::validator;


struct VotingPowerInfo has drop {
	validator_index: u64,
	voting_power: u64
}

adjust_voting_power(info_list: &mut vector<VotingPowerInfo>, threshold: u64, remaining_power: u64) {
L0:	len: u64
L1:	planned: u64
L2:	target: u64
L3:	v: &mut VotingPowerInfo
B0:
	0: LdU64(0)
	1: StLoc[5](i: u64)
	2: CopyLoc[0](info_list: &mut vector<VotingPowerInfo>)
	3: FreezeRef
	4: VecLen(10)
	5: StLoc[6](len: u64)
B1:
	6: CopyLoc[5](i: u64)
	7: CopyLoc[6](len: u64)
	8: Lt
	9: BrFalse(16)
B2:
	10: Branch(11)
B3:
	11: CopyLoc[2](remaining_power: u64)
	12: LdU64(0)
	13: Gt
	14: StLoc[3](%#1: bool)
	15: Branch(18)
B4:
	16: LdFalse
	17: StLoc[3](%#1: bool)
B5:
	18: MoveLoc[3](%#1: bool)
	19: BrFalse(74)
B6:
	20: CopyLoc[0](info_list: &mut vector<VotingPowerInfo>)
	21: CopyLoc[5](i: u64)
	22: VecMutBorrow(10)
	23: StLoc[9](v: &mut VotingPowerInfo)
	24: CopyLoc[2](remaining_power: u64)
	25: CopyLoc[6](len: u64)
	26: CopyLoc[5](i: u64)
	27: Sub
	28: Call math::divide_and_round_up(u64, u64): u64
	29: StLoc[7](planned: u64)
	30: CopyLoc[1](threshold: u64)
	31: CopyLoc[9](v: &mut VotingPowerInfo)
	32: ImmBorrowField[0](VotingPowerInfo.voting_power: u64)
	33: ReadRef
	34: MoveLoc[7](planned: u64)
	35: Add
	36: Call math::min(u64, u64): u64
	37: StLoc[8](target: u64)
	38: CopyLoc[2](remaining_power: u64)
	39: MoveLoc[8](target: u64)
	40: CopyLoc[9](v: &mut VotingPowerInfo)
	41: ImmBorrowField[0](VotingPowerInfo.voting_power: u64)
	42: ReadRef
	43: Sub
	44: Call math::min(u64, u64): u64
	45: StLoc[4](actual: u64)
	46: CopyLoc[9](v: &mut VotingPowerInfo)
	47: ImmBorrowField[0](VotingPowerInfo.voting_power: u64)
	48: ReadRef
	49: CopyLoc[4](actual: u64)
	50: Add
	51: CopyLoc[9](v: &mut VotingPowerInfo)
	52: MutBorrowField[0](VotingPowerInfo.voting_power: u64)
	53: WriteRef
	54: MoveLoc[9](v: &mut VotingPowerInfo)
	55: ImmBorrowField[0](VotingPowerInfo.voting_power: u64)
	56: ReadRef
	57: CopyLoc[1](threshold: u64)
	58: Le
	59: BrFalse(61)
B7:
	60: Branch(65)
B8:
	61: MoveLoc[0](info_list: &mut vector<VotingPowerInfo>)
	62: Pop
	63: LdConst[2](U64: [3, 0, 0, 0, 0, 0, 0, 0])
	64: Abort
B9:
	65: MoveLoc[2](remaining_power: u64)
	66: MoveLoc[4](actual: u64)
	67: Sub
	68: StLoc[2](remaining_power: u64)
	69: MoveLoc[5](i: u64)
	70: LdU64(1)
	71: Add
	72: StLoc[5](i: u64)
	73: Branch(6)
B10:
	74: MoveLoc[0](info_list: &mut vector<VotingPowerInfo>)
	75: Pop
	76: MoveLoc[2](remaining_power: u64)
	77: LdU64(0)
	78: Eq
	79: BrFalse(81)
B11:
	80: Branch(83)
B12:
	81: LdConst[1](U64: [1, 0, 0, 0, 0, 0, 0, 0])
	82: Abort
B13:
	83: Ret
}
check_invariants(v: &vector<Validator>) {
L0:	i#1: u64
L1:	j: u64
L2:	len: u64
L3:	power_i: u64
L4:	power_j: u64
L5:	stake_i: u64
L6:	stake_j: u64
L7:	total: u64
L8:	validator_i: &Validator
L9:	validator_j: &Validator
L10:	voting_power: u64
B0:
	0: LdU64(0)
	1: StLoc[1](i: u64)
	2: CopyLoc[0](v: &vector<Validator>)
	3: VecLen(13)
	4: StLoc[4](len: u64)
	5: LdU64(0)
	6: StLoc[9](total: u64)
B1:
	7: CopyLoc[1](i: u64)
	8: CopyLoc[4](len: u64)
	9: Lt
	10: BrFalse(26)
B2:
	11: Branch(12)
B3:
	12: CopyLoc[0](v: &vector<Validator>)
	13: CopyLoc[1](i: u64)
	14: VecImmBorrow(13)
	15: Call validator::voting_power(&Validator): u64
	16: StLoc[12](voting_power: u64)
	17: MoveLoc[9](total: u64)
	18: MoveLoc[12](voting_power: u64)
	19: Add
	20: StLoc[9](total: u64)
	21: MoveLoc[1](i: u64)
	22: LdU64(1)
	23: Add
	24: StLoc[1](i: u64)
	25: Branch(7)
B4:
	26: MoveLoc[9](total: u64)
	27: LdConst[5](U64: [16, 39, 0, 0, 0, 0, 0, 0])
	28: Eq
	29: BrFalse(31)
B5:
	30: Branch(35)
B6:
	31: MoveLoc[0](v: &vector<Validator>)
	32: Pop
	33: LdConst[1](U64: [1, 0, 0, 0, 0, 0, 0, 0])
	34: Abort
B7:
	35: LdU64(0)
	36: StLoc[2](i#1: u64)
B8:
	37: CopyLoc[2](i#1: u64)
	38: CopyLoc[4](len: u64)
	39: Lt
	40: BrFalse(107)
B9:
	41: Branch(42)
B10:
	42: CopyLoc[2](i#1: u64)
	43: LdU64(1)
	44: Add
	45: StLoc[3](j: u64)
B11:
	46: CopyLoc[3](j: u64)
	47: CopyLoc[4](len: u64)
	48: Lt
	49: BrFalse(102)
B12:
	50: Branch(51)
B13:
	51: CopyLoc[0](v: &vector<Validator>)
	52: CopyLoc[2](i#1: u64)
	53: VecImmBorrow(13)
	54: StLoc[10](validator_i: &Validator)
	55: CopyLoc[0](v: &vector<Validator>)
	56: CopyLoc[3](j: u64)
	57: VecImmBorrow(13)
	58: StLoc[11](validator_j: &Validator)
	59: CopyLoc[10](validator_i: &Validator)
	60: Call validator::total_stake(&Validator): u64
	61: StLoc[7](stake_i: u64)
	62: CopyLoc[11](validator_j: &Validator)
	63: Call validator::total_stake(&Validator): u64
	64: StLoc[8](stake_j: u64)
	65: MoveLoc[10](validator_i: &Validator)
	66: Call validator::voting_power(&Validator): u64
	67: StLoc[5](power_i: u64)
	68: MoveLoc[11](validator_j: &Validator)
	69: Call validator::voting_power(&Validator): u64
	70: StLoc[6](power_j: u64)
	71: CopyLoc[7](stake_i: u64)
	72: CopyLoc[7](stake_i: u64)
	73: Gt
	74: BrFalse(84)
B14:
	75: CopyLoc[5](power_i: u64)
	76: CopyLoc[6](power_j: u64)
	77: Ge
	78: BrFalse(80)
B15:
	79: Branch(84)
B16:
	80: MoveLoc[0](v: &vector<Validator>)
	81: Pop
	82: LdConst[0](U64: [2, 0, 0, 0, 0, 0, 0, 0])
	83: Abort
B17:
	84: MoveLoc[7](stake_i: u64)
	85: MoveLoc[8](stake_j: u64)
	86: Lt
	87: BrFalse(97)
B18:
	88: MoveLoc[5](power_i: u64)
	89: MoveLoc[6](power_j: u64)
	90: Le
	91: BrFalse(93)
B19:
	92: Branch(97)
B20:
	93: MoveLoc[0](v: &vector<Validator>)
	94: Pop
	95: LdConst[0](U64: [2, 0, 0, 0, 0, 0, 0, 0])
	96: Abort
B21:
	97: MoveLoc[3](j: u64)
	98: LdU64(1)
	99: Add
	100: StLoc[3](j: u64)
	101: Branch(46)
B22:
	102: MoveLoc[2](i#1: u64)
	103: LdU64(1)
	104: Add
	105: StLoc[2](i#1: u64)
	106: Branch(37)
B23:
	107: MoveLoc[0](v: &vector<Validator>)
	108: Pop
	109: Ret
}
init_voting_power_info(validators: &vector<Validator>, threshold: u64): vector<VotingPowerInfo> * u64 {
L0:	len: u64
L1:	result: vector<VotingPowerInfo>
L2:	total_power: u64
L3:	total_stake: u64
L4:	voting_power: u64
B0:
	0: CopyLoc[0](validators: &vector<Validator>)
	1: Call total_stake(&vector<Validator>): u64
	2: StLoc[7](total_stake: u64)
	3: LdU64(0)
	4: StLoc[2](i: u64)
	5: CopyLoc[0](validators: &vector<Validator>)
	6: VecLen(13)
	7: StLoc[4](len: u64)
	8: LdU64(0)
	9: StLoc[6](total_power: u64)
	10: VecPack(10, 0)
	11: StLoc[5](result: vector<VotingPowerInfo>)
B1:
	12: CopyLoc[2](i: u64)
	13: CopyLoc[4](len: u64)
	14: Lt
	15: BrFalse(48)
B2:
	16: Branch(17)
B3:
	17: CopyLoc[0](validators: &vector<Validator>)
	18: CopyLoc[2](i: u64)
	19: VecImmBorrow(13)
	20: Call validator::total_stake(&Validator): u64
	21: CastU128
	22: LdConst[5](U64: [16, 39, 0, 0, 0, 0, 0, 0])
	23: CastU128
	24: Mul
	25: CopyLoc[7](total_stake: u64)
	26: CastU128
	27: Div
	28: CastU64
	29: CopyLoc[1](threshold: u64)
	30: Call math::min(u64, u64): u64
	31: StLoc[8](voting_power: u64)
	32: CopyLoc[2](i: u64)
	33: CopyLoc[8](voting_power: u64)
	34: Pack[0](VotingPowerInfo)
	35: StLoc[3](info: VotingPowerInfo)
	36: MutBorrowLoc[5](result: vector<VotingPowerInfo>)
	37: MoveLoc[3](info: VotingPowerInfo)
	38: Call insert(&mut vector<VotingPowerInfo>, VotingPowerInfo)
	39: MoveLoc[6](total_power: u64)
	40: MoveLoc[8](voting_power: u64)
	41: Add
	42: StLoc[6](total_power: u64)
	43: MoveLoc[2](i: u64)
	44: LdU64(1)
	45: Add
	46: StLoc[2](i: u64)
	47: Branch(12)
B4:
	48: MoveLoc[0](validators: &vector<Validator>)
	49: Pop
	50: MoveLoc[5](result: vector<VotingPowerInfo>)
	51: LdConst[5](U64: [16, 39, 0, 0, 0, 0, 0, 0])
	52: MoveLoc[6](total_power: u64)
	53: Sub
	54: Ret
}
insert(info_list: &mut vector<VotingPowerInfo>, new_info: VotingPowerInfo) {
L0:	i: u64
L1:	len: u64
B0:
	0: LdU64(0)
	1: StLoc[4](i: u64)
	2: CopyLoc[0](info_list: &mut vector<VotingPowerInfo>)
	3: FreezeRef
	4: VecLen(10)
	5: StLoc[5](len: u64)
B1:
	6: CopyLoc[4](i: u64)
	7: CopyLoc[5](len: u64)
	8: Lt
	9: BrFalse(25)
B2:
	10: Branch(11)
B3:
	11: CopyLoc[0](info_list: &mut vector<VotingPowerInfo>)
	12: CopyLoc[4](i: u64)
	13: StLoc[2](%#2: u64)
	14: FreezeRef
	15: MoveLoc[2](%#2: u64)
	16: VecImmBorrow(10)
	17: ImmBorrowField[0](VotingPowerInfo.voting_power: u64)
	18: ReadRef
	19: ImmBorrowLoc[1](new_info: VotingPowerInfo)
	20: ImmBorrowField[0](VotingPowerInfo.voting_power: u64)
	21: ReadRef
	22: Gt
	23: StLoc[3](%#3: bool)
	24: Branch(27)
B4:
	25: LdFalse
	26: StLoc[3](%#3: bool)
B5:
	27: MoveLoc[3](%#3: bool)
	28: BrFalse(34)
B6:
	29: MoveLoc[4](i: u64)
	30: LdU64(1)
	31: Add
	32: StLoc[4](i: u64)
	33: Branch(6)
B7:
	34: MoveLoc[0](info_list: &mut vector<VotingPowerInfo>)
	35: MoveLoc[1](new_info: VotingPowerInfo)
	36: MoveLoc[4](i: u64)
	37: Call vector::insert<VotingPowerInfo>(&mut vector<VotingPowerInfo>, VotingPowerInfo, u64)
	38: Ret
}
public quorum_threshold(): u64 {
B0:
	0: LdConst[4](U64: [11, 26, 0, 0, 0, 0, 0, 0])
	1: Ret
}
public set_voting_power(validators: &mut vector<Validator>) {
L0:	info_list: vector<VotingPowerInfo>
L1:	remaining_power: u64
L2:	threshold: u64
B0:
	0: LdConst[5](U64: [16, 39, 0, 0, 0, 0, 0, 0])
	1: LdConst[3](U64: [232, 3, 0, 0, 0, 0, 0, 0])
	2: LdConst[5](U64: [16, 39, 0, 0, 0, 0, 0, 0])
	3: CopyLoc[0](validators: &mut vector<Validator>)
	4: FreezeRef
	5: VecLen(13)
	6: Call math::divide_and_round_up(u64, u64): u64
	7: Call math::max(u64, u64): u64
	8: Call math::min(u64, u64): u64
	9: StLoc[4](threshold: u64)
	10: CopyLoc[0](validators: &mut vector<Validator>)
	11: CopyLoc[4](threshold: u64)
	12: StLoc[1](%#2: u64)
	13: FreezeRef
	14: MoveLoc[1](%#2: u64)
	15: Call init_voting_power_info(&vector<Validator>, u64): vector<VotingPowerInfo> * u64
	16: StLoc[3](remaining_power: u64)
	17: StLoc[2](info_list: vector<VotingPowerInfo>)
	18: MutBorrowLoc[2](info_list: vector<VotingPowerInfo>)
	19: MoveLoc[4](threshold: u64)
	20: MoveLoc[3](remaining_power: u64)
	21: Call adjust_voting_power(&mut vector<VotingPowerInfo>, u64, u64)
	22: CopyLoc[0](validators: &mut vector<Validator>)
	23: MoveLoc[2](info_list: vector<VotingPowerInfo>)
	24: Call update_voting_power(&mut vector<Validator>, vector<VotingPowerInfo>)
	25: MoveLoc[0](validators: &mut vector<Validator>)
	26: FreezeRef
	27: Call check_invariants(&vector<Validator>)
	28: Ret
}
total_stake(validators: &vector<Validator>): u64 {
L0:	len: u64
L1:	total_stake: u64
B0:
	0: LdU64(0)
	1: StLoc[1](i: u64)
	2: CopyLoc[0](validators: &vector<Validator>)
	3: VecLen(13)
	4: StLoc[2](len: u64)
	5: LdU64(0)
	6: StLoc[3](total_stake: u64)
B1:
	7: CopyLoc[1](i: u64)
	8: CopyLoc[2](len: u64)
	9: Lt
	10: BrFalse(24)
B2:
	11: Branch(12)
B3:
	12: MoveLoc[3](total_stake: u64)
	13: CopyLoc[0](validators: &vector<Validator>)
	14: CopyLoc[1](i: u64)
	15: VecImmBorrow(13)
	16: Call validator::total_stake(&Validator): u64
	17: Add
	18: StLoc[3](total_stake: u64)
	19: MoveLoc[1](i: u64)
	20: LdU64(1)
	21: Add
	22: StLoc[1](i: u64)
	23: Branch(7)
B4:
	24: MoveLoc[0](validators: &vector<Validator>)
	25: Pop
	26: MoveLoc[3](total_stake: u64)
	27: Ret
}
public total_voting_power(): u64 {
B0:
	0: LdConst[5](U64: [16, 39, 0, 0, 0, 0, 0, 0])
	1: Ret
}
update_voting_power(validators: &mut vector<Validator>, info_list: vector<VotingPowerInfo>) {
B0:
	0: ImmBorrowLoc[1](info_list: vector<VotingPowerInfo>)
	1: Call vector::is_empty<VotingPowerInfo>(&vector<VotingPowerInfo>): bool
	2: Not
	3: BrFalse(16)
B1:
	4: Branch(5)
B2:
	5: MutBorrowLoc[1](info_list: vector<VotingPowerInfo>)
	6: VecPopBack(10)
	7: Unpack[0](VotingPowerInfo)
	8: StLoc[3](voting_power: u64)
	9: StLoc[2](validator_index: u64)
	10: CopyLoc[0](validators: &mut vector<Validator>)
	11: MoveLoc[2](validator_index: u64)
	12: VecMutBorrow(13)
	13: MoveLoc[3](voting_power: u64)
	14: Call validator::set_voting_power(&mut Validator, u64)
	15: Branch(0)
B3:
	16: MoveLoc[0](validators: &mut vector<Validator>)
	17: Pop
	18: MoveLoc[1](info_list: vector<VotingPowerInfo>)
	19: VecUnpack(10, 0)
	20: Ret
}
}
