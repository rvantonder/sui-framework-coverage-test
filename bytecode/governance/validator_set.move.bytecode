// Move bytecode v6
module 2.validator_set {
use 0000000000000000000000000000000000000001::option;
use 0000000000000000000000000000000000000001::vector;
use 0000000000000000000000000000000000000002::balance;
use 0000000000000000000000000000000000000002::epoch_time_lock;
use 0000000000000000000000000000000000000002::event;
use 0000000000000000000000000000000000000002::priority_queue;
use 0000000000000000000000000000000000000002::stake;
use 0000000000000000000000000000000000000002::staking_pool;
use 0000000000000000000000000000000000000002::sui;
use 0000000000000000000000000000000000000002::table_vec;
use 0000000000000000000000000000000000000002::tx_context;
use 0000000000000000000000000000000000000002::validator;
use 0000000000000000000000000000000000000002::vec_map;
use 0000000000000000000000000000000000000002::vec_set;
use 0000000000000000000000000000000000000002::voting_power;


struct DelegationRequestEvent has copy, drop {
	validator_address: address,
	delegator_address: address,
	epoch: u64,
	amount: u64
}
struct ValidatorEpochInfo has copy, drop {
	epoch: u64,
	validator_address: address,
	reference_gas_survey_quote: u64,
	validator_stake: u64,
	delegated_stake: u64,
	commission_rate: u64,
	stake_rewards: u64,
	pool_token_exchange_rate: PoolTokenExchangeRate,
	tallying_rule_reporters: vector<address>,
	tallying_rule_global_score: u64
}
struct ValidatorPair has copy, drop, store {
	from: address,
	to: address
}
struct ValidatorSet has store {
	total_validator_stake: u64,
	total_delegation_stake: u64,
	active_validators: vector<Validator>,
	pending_validators: vector<Validator>,
	pending_removals: vector<u64>,
	next_epoch_validators: vector<ValidatorMetadata>,
	pending_delegation_switches: VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>
}

public active_validators(self: &ValidatorSet): &vector<Validator> {
B0:
	0: MoveLoc[0](self: &ValidatorSet)
	1: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	2: Ret
}
adjust_stake_and_gas_price(validators: &mut vector<Validator>) {
L0:	length: u64
B0:
	0: CopyLoc[0](validators: &mut vector<Validator>)
	1: FreezeRef
	2: VecLen(42)
	3: StLoc[2](length: u64)
	4: LdU64(0)
	5: StLoc[1](i: u64)
B1:
	6: CopyLoc[1](i: u64)
	7: CopyLoc[2](length: u64)
	8: Lt
	9: BrFalse(20)
B2:
	10: Branch(11)
B3:
	11: CopyLoc[0](validators: &mut vector<Validator>)
	12: CopyLoc[1](i: u64)
	13: VecMutBorrow(42)
	14: Call validator::adjust_stake_and_gas_price(&mut Validator)
	15: MoveLoc[1](i: u64)
	16: LdU64(1)
	17: Add
	18: StLoc[1](i: u64)
	19: Branch(6)
B4:
	20: MoveLoc[0](validators: &mut vector<Validator>)
	21: Pop
	22: Ret
}
public(friend) advance_epoch(new_epoch: u64, self: &mut ValidatorSet, computation_reward: &mut Balance<SUI>, storage_fund_reward: &mut Balance<SUI>, validator_report_records: VecMap<address, VecSet<address>>, reward_slashing_rate: u64, ctx: &mut TxContext) {
L0:	total_slashed_validator_stake: u64
L1:	total_stake: u64
L2:	total_staking_reward_adjustment: u64
L3:	total_storage_fund_reward_adjustment: u64
L4:	unadjusted_staking_reward_amounts: vector<u64>
L5:	unadjusted_storage_fund_reward_amounts: vector<u64>
B0:
	0: CopyLoc[1](self: &mut ValidatorSet)
	1: ImmBorrowField[1](ValidatorSet.total_validator_stake: u64)
	2: ReadRef
	3: CopyLoc[1](self: &mut ValidatorSet)
	4: ImmBorrowField[2](ValidatorSet.total_delegation_stake: u64)
	5: ReadRef
	6: Add
	7: StLoc[15](total_stake: u64)
	8: CopyLoc[1](self: &mut ValidatorSet)
	9: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	10: CopyLoc[15](total_stake: u64)
	11: CopyLoc[2](computation_reward: &mut Balance<SUI>)
	12: FreezeRef
	13: Call balance::value<SUI>(&Balance<SUI>): u64
	14: CopyLoc[3](storage_fund_reward: &mut Balance<SUI>)
	15: FreezeRef
	16: Call balance::value<SUI>(&Balance<SUI>): u64
	17: Call compute_unadjusted_reward_distribution(&vector<Validator>, u64, u64, u64): vector<u64> * vector<u64>
	18: StLoc[19](unadjusted_storage_fund_reward_amounts: vector<u64>)
	19: StLoc[18](unadjusted_staking_reward_amounts: vector<u64>)
	20: CopyLoc[1](self: &mut ValidatorSet)
	21: CopyLoc[4](validator_report_records: VecMap<address, VecSet<address>>)
	22: StLoc[7](%#2: VecMap<address, VecSet<address>>)
	23: FreezeRef
	24: MoveLoc[7](%#2: VecMap<address, VecSet<address>>)
	25: Call compute_slashed_validators_and_total_stake(&ValidatorSet, VecMap<address, VecSet<address>>): vector<address> * u64
	26: StLoc[14](total_slashed_validator_stake: u64)
	27: StLoc[13](slashed_validators: vector<address>)
	28: CopyLoc[1](self: &mut ValidatorSet)
	29: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	30: ImmBorrowLoc[13](slashed_validators: vector<address>)
	31: Call get_validator_indices(&vector<Validator>, &vector<address>): vector<u64>
	32: MoveLoc[5](reward_slashing_rate: u64)
	33: ImmBorrowLoc[18](unadjusted_staking_reward_amounts: vector<u64>)
	34: ImmBorrowLoc[19](unadjusted_storage_fund_reward_amounts: vector<u64>)
	35: Call compute_reward_adjustments(vector<u64>, u64, &vector<u64>, &vector<u64>): u64 * VecMap<u64, u64> * u64 * VecMap<u64, u64>
	36: StLoc[12](individual_storage_fund_reward_adjustments: VecMap<u64, u64>)
	37: StLoc[17](total_storage_fund_reward_adjustment: u64)
	38: StLoc[11](individual_staking_reward_adjustments: VecMap<u64, u64>)
	39: StLoc[16](total_staking_reward_adjustment: u64)
	40: CopyLoc[1](self: &mut ValidatorSet)
	41: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	42: MoveLoc[15](total_stake: u64)
	43: MoveLoc[14](total_slashed_validator_stake: u64)
	44: MoveLoc[18](unadjusted_staking_reward_amounts: vector<u64>)
	45: MoveLoc[19](unadjusted_storage_fund_reward_amounts: vector<u64>)
	46: MoveLoc[16](total_staking_reward_adjustment: u64)
	47: MoveLoc[11](individual_staking_reward_adjustments: VecMap<u64, u64>)
	48: MoveLoc[17](total_storage_fund_reward_adjustment: u64)
	49: MoveLoc[12](individual_storage_fund_reward_adjustments: VecMap<u64, u64>)
	50: Call compute_adjusted_reward_distribution(&vector<Validator>, u64, u64, vector<u64>, vector<u64>, u64, VecMap<u64, u64>, u64, VecMap<u64, u64>): vector<u64> * vector<u64>
	51: StLoc[9](adjusted_storage_fund_reward_amounts: vector<u64>)
	52: StLoc[8](adjusted_staking_reward_amounts: vector<u64>)
	53: CopyLoc[1](self: &mut ValidatorSet)
	54: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	55: ImmBorrowLoc[8](adjusted_staking_reward_amounts: vector<u64>)
	56: ImmBorrowLoc[9](adjusted_storage_fund_reward_amounts: vector<u64>)
	57: MoveLoc[2](computation_reward: &mut Balance<SUI>)
	58: MoveLoc[3](storage_fund_reward: &mut Balance<SUI>)
	59: CopyLoc[6](ctx: &mut TxContext)
	60: Call distribute_reward(&mut vector<Validator>, &vector<u64>, &vector<u64>, &mut Balance<SUI>, &mut Balance<SUI>, &mut TxContext)
	61: CopyLoc[1](self: &mut ValidatorSet)
	62: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	63: Call adjust_stake_and_gas_price(&mut vector<Validator>)
	64: CopyLoc[1](self: &mut ValidatorSet)
	65: CopyLoc[6](ctx: &mut TxContext)
	66: Call process_pending_delegation_switches(&mut ValidatorSet, &mut TxContext)
	67: CopyLoc[1](self: &mut ValidatorSet)
	68: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	69: CopyLoc[6](ctx: &mut TxContext)
	70: Call process_pending_delegations_and_withdraws(&mut vector<Validator>, &mut TxContext)
	71: MoveLoc[0](new_epoch: u64)
	72: CopyLoc[1](self: &mut ValidatorSet)
	73: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	74: ImmBorrowLoc[8](adjusted_staking_reward_amounts: vector<u64>)
	75: ImmBorrowLoc[4](validator_report_records: VecMap<address, VecSet<address>>)
	76: ImmBorrowLoc[13](slashed_validators: vector<address>)
	77: Call emit_validator_epoch_events(u64, &vector<Validator>, &vector<u64>, &VecMap<address, VecSet<address>>, &vector<address>)
	78: CopyLoc[1](self: &mut ValidatorSet)
	79: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	80: CopyLoc[1](self: &mut ValidatorSet)
	81: MutBorrowField[3](ValidatorSet.pending_validators: vector<Validator>)
	82: Call process_pending_validators(&mut vector<Validator>, &mut vector<Validator>)
	83: CopyLoc[1](self: &mut ValidatorSet)
	84: MoveLoc[6](ctx: &mut TxContext)
	85: Call process_pending_removals(&mut ValidatorSet, &mut TxContext)
	86: CopyLoc[1](self: &mut ValidatorSet)
	87: FreezeRef
	88: Call derive_next_epoch_validators(&ValidatorSet): vector<ValidatorMetadata>
	89: CopyLoc[1](self: &mut ValidatorSet)
	90: MutBorrowField[4](ValidatorSet.next_epoch_validators: vector<ValidatorMetadata>)
	91: WriteRef
	92: CopyLoc[1](self: &mut ValidatorSet)
	93: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	94: Call calculate_total_stakes(&vector<Validator>): u64 * u64
	95: StLoc[10](delegation_stake: u64)
	96: CopyLoc[1](self: &mut ValidatorSet)
	97: MutBorrowField[1](ValidatorSet.total_validator_stake: u64)
	98: WriteRef
	99: MoveLoc[10](delegation_stake: u64)
	100: CopyLoc[1](self: &mut ValidatorSet)
	101: MutBorrowField[2](ValidatorSet.total_delegation_stake: u64)
	102: WriteRef
	103: MoveLoc[1](self: &mut ValidatorSet)
	104: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	105: Call voting_power::set_voting_power(&mut vector<Validator>)
	106: Ret
}
calculate_total_stakes(validators: &vector<Validator>): u64 * u64 {
L0:	i: u64
L1:	length: u64
L2:	v: &Validator
L3:	validator_state: u64
B0:
	0: LdU64(0)
	1: StLoc[5](validator_state: u64)
	2: LdU64(0)
	3: StLoc[1](delegate_stake: u64)
	4: CopyLoc[0](validators: &vector<Validator>)
	5: VecLen(42)
	6: StLoc[3](length: u64)
	7: LdU64(0)
	8: StLoc[2](i: u64)
B1:
	9: CopyLoc[2](i: u64)
	10: CopyLoc[3](length: u64)
	11: Lt
	12: BrFalse(33)
B2:
	13: Branch(14)
B3:
	14: CopyLoc[0](validators: &vector<Validator>)
	15: CopyLoc[2](i: u64)
	16: VecImmBorrow(42)
	17: StLoc[4](v: &Validator)
	18: MoveLoc[5](validator_state: u64)
	19: CopyLoc[4](v: &Validator)
	20: Call validator::stake_amount(&Validator): u64
	21: Add
	22: StLoc[5](validator_state: u64)
	23: MoveLoc[1](delegate_stake: u64)
	24: MoveLoc[4](v: &Validator)
	25: Call validator::delegate_amount(&Validator): u64
	26: Add
	27: StLoc[1](delegate_stake: u64)
	28: MoveLoc[2](i: u64)
	29: LdU64(1)
	30: Add
	31: StLoc[2](i: u64)
	32: Branch(9)
B4:
	33: MoveLoc[0](validators: &vector<Validator>)
	34: Pop
	35: MoveLoc[5](validator_state: u64)
	36: MoveLoc[1](delegate_stake: u64)
	37: Ret
}
public(friend) cancel_delegation_request(self: &mut ValidatorSet, staked_sui: StakedSui, ctx: &mut TxContext) {
B0:
	0: ImmBorrowLoc[1](staked_sui: StakedSui)
	1: Call staking_pool::validator_address(&StakedSui): address
	2: StLoc[3](validator_address: address)
	3: MoveLoc[0](self: &mut ValidatorSet)
	4: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	5: MoveLoc[3](validator_address: address)
	6: Call get_validator_mut(&mut vector<Validator>, address): &mut Validator
	7: MoveLoc[1](staked_sui: StakedSui)
	8: MoveLoc[2](ctx: &mut TxContext)
	9: Call validator::cancel_delegation_request(&mut Validator, StakedSui, &mut TxContext)
	10: Ret
}
compute_adjusted_reward_distribution(validators: &vector<Validator>, total_stake: u64, total_slashed_validator_stake: u64, unadjusted_staking_reward_amounts: vector<u64>, unadjusted_storage_fund_reward_amounts: vector<u64>, total_staking_reward_adjustment: u64, individual_staking_reward_adjustments: VecMap<u64, u64>, total_storage_fund_reward_adjustment: u64, individual_storage_fund_reward_adjustments: VecMap<u64, u64>): vector<u64> * vector<u64> {
L0:	adjustment#4: u64
L1:	i: u64
L2:	length: u64
L3:	num_unslashed_validators: u64
L4:	stake_amount: u128
L5:	total_unslashed_validator_stake: u64
L6:	unadjusted_staking_reward_amount: u64
L7:	unadjusted_storage_fund_reward_amount: u64
B0:
	0: MoveLoc[1](total_stake: u64)
	1: MoveLoc[2](total_slashed_validator_stake: u64)
	2: Sub
	3: StLoc[23](total_unslashed_validator_stake: u64)
	4: VecPack(17, 0)
	5: StLoc[12](adjusted_staking_reward_amounts: vector<u64>)
	6: VecPack(17, 0)
	7: StLoc[14](adjusted_storage_fund_reward_amounts: vector<u64>)
	8: CopyLoc[0](validators: &vector<Validator>)
	9: VecLen(42)
	10: StLoc[20](length: u64)
	11: CopyLoc[20](length: u64)
	12: ImmBorrowLoc[6](individual_staking_reward_adjustments: VecMap<u64, u64>)
	13: Call vec_map::size<u64, u64>(&VecMap<u64, u64>): u64
	14: Sub
	15: StLoc[21](num_unslashed_validators: u64)
	16: LdU64(0)
	17: StLoc[19](i: u64)
B1:
	18: CopyLoc[19](i: u64)
	19: CopyLoc[20](length: u64)
	20: Lt
	21: BrFalse(103)
B2:
	22: Branch(23)
B3:
	23: CopyLoc[0](validators: &vector<Validator>)
	24: CopyLoc[19](i: u64)
	25: VecImmBorrow(42)
	26: Call validator::total_stake_amount(&Validator): u64
	27: CastU128
	28: StLoc[22](stake_amount: u128)
	29: ImmBorrowLoc[3](unadjusted_staking_reward_amounts: vector<u64>)
	30: CopyLoc[19](i: u64)
	31: VecImmBorrow(17)
	32: ReadRef
	33: StLoc[24](unadjusted_staking_reward_amount: u64)
	34: ImmBorrowLoc[6](individual_staking_reward_adjustments: VecMap<u64, u64>)
	35: ImmBorrowLoc[19](i: u64)
	36: Call vec_map::contains<u64, u64>(&VecMap<u64, u64>, &u64): bool
	37: BrFalse(48)
B4:
	38: ImmBorrowLoc[6](individual_staking_reward_adjustments: VecMap<u64, u64>)
	39: ImmBorrowLoc[19](i: u64)
	40: Call vec_map::get<u64, u64>(&VecMap<u64, u64>, &u64): &u64
	41: ReadRef
	42: StLoc[15](adjustment: u64)
	43: MoveLoc[24](unadjusted_staking_reward_amount: u64)
	44: MoveLoc[15](adjustment: u64)
	45: Sub
	46: StLoc[9](%#2: u64)
	47: Branch(61)
B5:
	48: CopyLoc[5](total_staking_reward_adjustment: u64)
	49: CastU128
	50: MoveLoc[22](stake_amount: u128)
	51: Mul
	52: CopyLoc[23](total_unslashed_validator_stake: u64)
	53: CastU128
	54: Div
	55: StLoc[16](adjustment#1: u128)
	56: MoveLoc[24](unadjusted_staking_reward_amount: u64)
	57: MoveLoc[16](adjustment#1: u128)
	58: CastU64
	59: Add
	60: StLoc[9](%#2: u64)
B6:
	61: MoveLoc[9](%#2: u64)
	62: StLoc[11](adjusted_staking_reward_amount: u64)
	63: MutBorrowLoc[12](adjusted_staking_reward_amounts: vector<u64>)
	64: MoveLoc[11](adjusted_staking_reward_amount: u64)
	65: VecPushBack(17)
	66: ImmBorrowLoc[4](unadjusted_storage_fund_reward_amounts: vector<u64>)
	67: CopyLoc[19](i: u64)
	68: VecImmBorrow(17)
	69: ReadRef
	70: StLoc[25](unadjusted_storage_fund_reward_amount: u64)
	71: ImmBorrowLoc[8](individual_storage_fund_reward_adjustments: VecMap<u64, u64>)
	72: ImmBorrowLoc[19](i: u64)
	73: Call vec_map::contains<u64, u64>(&VecMap<u64, u64>, &u64): bool
	74: BrFalse(85)
B7:
	75: ImmBorrowLoc[8](individual_storage_fund_reward_adjustments: VecMap<u64, u64>)
	76: ImmBorrowLoc[19](i: u64)
	77: Call vec_map::get<u64, u64>(&VecMap<u64, u64>, &u64): &u64
	78: ReadRef
	79: StLoc[17](adjustment#3: u64)
	80: MoveLoc[25](unadjusted_storage_fund_reward_amount: u64)
	81: MoveLoc[17](adjustment#3: u64)
	82: Sub
	83: StLoc[10](%#5: u64)
	84: Branch(93)
B8:
	85: CopyLoc[7](total_storage_fund_reward_adjustment: u64)
	86: CopyLoc[21](num_unslashed_validators: u64)
	87: Div
	88: StLoc[18](adjustment#4: u64)
	89: MoveLoc[25](unadjusted_storage_fund_reward_amount: u64)
	90: MoveLoc[18](adjustment#4: u64)
	91: Add
	92: StLoc[10](%#5: u64)
B9:
	93: MoveLoc[10](%#5: u64)
	94: StLoc[13](adjusted_storage_fund_reward_amount: u64)
	95: MutBorrowLoc[14](adjusted_storage_fund_reward_amounts: vector<u64>)
	96: MoveLoc[13](adjusted_storage_fund_reward_amount: u64)
	97: VecPushBack(17)
	98: MoveLoc[19](i: u64)
	99: LdU64(1)
	100: Add
	101: StLoc[19](i: u64)
	102: Branch(18)
B10:
	103: MoveLoc[0](validators: &vector<Validator>)
	104: Pop
	105: MoveLoc[12](adjusted_staking_reward_amounts: vector<u64>)
	106: MoveLoc[14](adjusted_storage_fund_reward_amounts: vector<u64>)
	107: Ret
}
compute_reward_adjustments(slashed_validator_indices: vector<u64>, reward_slashing_rate: u64, unadjusted_staking_reward_amounts: &vector<u64>, unadjusted_storage_fund_reward_amounts: &vector<u64>): u64 * VecMap<u64, u64> * u64 * VecMap<u64, u64> {
L0:	total_staking_reward_adjustment: u64
L1:	total_storage_fund_reward_adjustment: u64
L2:	validator_index: u64
B0:
	0: LdU64(0)
	1: StLoc[8](total_staking_reward_adjustment: u64)
	2: Call vec_map::empty<u64, u64>(): VecMap<u64, u64>
	3: StLoc[4](individual_staking_reward_adjustments: VecMap<u64, u64>)
	4: LdU64(0)
	5: StLoc[9](total_storage_fund_reward_adjustment: u64)
	6: Call vec_map::empty<u64, u64>(): VecMap<u64, u64>
	7: StLoc[5](individual_storage_fund_reward_adjustments: VecMap<u64, u64>)
B1:
	8: MutBorrowLoc[0](slashed_validator_indices: vector<u64>)
	9: FreezeRef
	10: Call vector::is_empty<u64>(&vector<u64>): bool
	11: Not
	12: BrFalse(60)
B2:
	13: Branch(14)
B3:
	14: MutBorrowLoc[0](slashed_validator_indices: vector<u64>)
	15: VecPopBack(17)
	16: StLoc[10](validator_index: u64)
	17: CopyLoc[2](unadjusted_staking_reward_amounts: &vector<u64>)
	18: CopyLoc[10](validator_index: u64)
	19: VecImmBorrow(17)
	20: ReadRef
	21: CastU128
	22: CopyLoc[1](reward_slashing_rate: u64)
	23: CastU128
	24: Mul
	25: LdConst[0](U128: [16, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
	26: Div
	27: StLoc[6](staking_reward_adjustment_u128: u128)
	28: MutBorrowLoc[4](individual_staking_reward_adjustments: VecMap<u64, u64>)
	29: CopyLoc[10](validator_index: u64)
	30: CopyLoc[6](staking_reward_adjustment_u128: u128)
	31: CastU64
	32: Call vec_map::insert<u64, u64>(&mut VecMap<u64, u64>, u64, u64)
	33: MoveLoc[8](total_staking_reward_adjustment: u64)
	34: MoveLoc[6](staking_reward_adjustment_u128: u128)
	35: CastU64
	36: Add
	37: StLoc[8](total_staking_reward_adjustment: u64)
	38: CopyLoc[3](unadjusted_storage_fund_reward_amounts: &vector<u64>)
	39: CopyLoc[10](validator_index: u64)
	40: VecImmBorrow(17)
	41: ReadRef
	42: CastU128
	43: CopyLoc[1](reward_slashing_rate: u64)
	44: CastU128
	45: Mul
	46: LdConst[0](U128: [16, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
	47: Div
	48: StLoc[7](storage_fund_reward_adjustment_u128: u128)
	49: MutBorrowLoc[5](individual_storage_fund_reward_adjustments: VecMap<u64, u64>)
	50: MoveLoc[10](validator_index: u64)
	51: CopyLoc[7](storage_fund_reward_adjustment_u128: u128)
	52: CastU64
	53: Call vec_map::insert<u64, u64>(&mut VecMap<u64, u64>, u64, u64)
	54: MoveLoc[9](total_storage_fund_reward_adjustment: u64)
	55: MoveLoc[7](storage_fund_reward_adjustment_u128: u128)
	56: CastU64
	57: Add
	58: StLoc[9](total_storage_fund_reward_adjustment: u64)
	59: Branch(8)
B4:
	60: MoveLoc[3](unadjusted_storage_fund_reward_amounts: &vector<u64>)
	61: Pop
	62: MoveLoc[2](unadjusted_staking_reward_amounts: &vector<u64>)
	63: Pop
	64: MoveLoc[8](total_staking_reward_adjustment: u64)
	65: MoveLoc[4](individual_staking_reward_adjustments: VecMap<u64, u64>)
	66: MoveLoc[9](total_storage_fund_reward_adjustment: u64)
	67: MoveLoc[5](individual_storage_fund_reward_adjustments: VecMap<u64, u64>)
	68: Ret
}
compute_slashed_validators_and_total_stake(self: &ValidatorSet, validator_report_records: VecMap<address, VecSet<address>>): vector<address> * u64 {
L0:	reporters: VecSet<address>
L1:	slashed_validators: vector<address>
L2:	sum_of_stake: u64
L3:	validator_address: address
B0:
	0: LdConst[3](Vector(Address): [0])
	1: StLoc[5](slashed_validators: vector<address>)
	2: LdU64(0)
	3: StLoc[6](sum_of_stake: u64)
B1:
	4: ImmBorrowLoc[1](validator_report_records: VecMap<address, VecSet<address>>)
	5: Call vec_map::is_empty<address, VecSet<address>>(&VecMap<address, VecSet<address>>): bool
	6: Not
	7: BrFalse(44)
B2:
	8: Branch(9)
B3:
	9: MutBorrowLoc[1](validator_report_records: VecMap<address, VecSet<address>>)
	10: Call vec_map::pop<address, VecSet<address>>(&mut VecMap<address, VecSet<address>>): address * VecSet<address>
	11: StLoc[4](reporters: VecSet<address>)
	12: StLoc[7](validator_address: address)
	13: CopyLoc[0](self: &ValidatorSet)
	14: CopyLoc[7](validator_address: address)
	15: Call is_active_validator(&ValidatorSet, address): bool
	16: BrFalse(18)
B4:
	17: Branch(22)
B5:
	18: MoveLoc[0](self: &ValidatorSet)
	19: Pop
	20: LdConst[2](U64: [0, 0, 0, 0, 0, 0, 0, 0])
	21: Abort
B6:
	22: CopyLoc[0](self: &ValidatorSet)
	23: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	24: StLoc[3](%#2: &vector<Validator>)
	25: MoveLoc[4](reporters: VecSet<address>)
	26: Call vec_set::into_keys<address>(VecSet<address>): vector<address>
	27: StLoc[2](%#1: vector<address>)
	28: MoveLoc[3](%#2: &vector<Validator>)
	29: ImmBorrowLoc[2](%#1: vector<address>)
	30: Call sum_voting_power_by_addresses(&vector<Validator>, &vector<address>): u64
	31: Call voting_power::quorum_threshold(): u64
	32: Ge
	33: BrFalse(43)
B7:
	34: MoveLoc[6](sum_of_stake: u64)
	35: CopyLoc[0](self: &ValidatorSet)
	36: CopyLoc[7](validator_address: address)
	37: Call validator_total_stake_amount(&ValidatorSet, address): u64
	38: Add
	39: StLoc[6](sum_of_stake: u64)
	40: MutBorrowLoc[5](slashed_validators: vector<address>)
	41: MoveLoc[7](validator_address: address)
	42: VecPushBack(47)
B8:
	43: Branch(4)
B9:
	44: MoveLoc[0](self: &ValidatorSet)
	45: Pop
	46: MoveLoc[5](slashed_validators: vector<address>)
	47: MoveLoc[6](sum_of_stake: u64)
	48: Ret
}
compute_unadjusted_reward_distribution(validators: &vector<Validator>, total_stake: u64, total_staking_reward: u64, total_storage_fund_reward: u64): vector<u64> * vector<u64> {
L0:	storage_fund_reward_amounts: vector<u64>
L1:	storage_fund_reward_per_validator: u64
B0:
	0: VecPack(17, 0)
	1: StLoc[7](staking_reward_amounts: vector<u64>)
	2: VecPack(17, 0)
	3: StLoc[8](storage_fund_reward_amounts: vector<u64>)
	4: CopyLoc[0](validators: &vector<Validator>)
	5: VecLen(42)
	6: StLoc[5](length: u64)
	7: MoveLoc[3](total_storage_fund_reward: u64)
	8: CopyLoc[5](length: u64)
	9: Div
	10: StLoc[9](storage_fund_reward_per_validator: u64)
	11: LdU64(0)
	12: StLoc[4](i: u64)
B1:
	13: CopyLoc[4](i: u64)
	14: CopyLoc[5](length: u64)
	15: Lt
	16: BrFalse(42)
B2:
	17: Branch(18)
B3:
	18: CopyLoc[0](validators: &vector<Validator>)
	19: CopyLoc[4](i: u64)
	20: VecImmBorrow(42)
	21: Call validator::total_stake_amount(&Validator): u64
	22: CastU128
	23: CopyLoc[2](total_staking_reward: u64)
	24: CastU128
	25: Mul
	26: CopyLoc[1](total_stake: u64)
	27: CastU128
	28: Div
	29: StLoc[6](reward_amount: u128)
	30: MutBorrowLoc[7](staking_reward_amounts: vector<u64>)
	31: MoveLoc[6](reward_amount: u128)
	32: CastU64
	33: VecPushBack(17)
	34: MutBorrowLoc[8](storage_fund_reward_amounts: vector<u64>)
	35: CopyLoc[9](storage_fund_reward_per_validator: u64)
	36: VecPushBack(17)
	37: MoveLoc[4](i: u64)
	38: LdU64(1)
	39: Add
	40: StLoc[4](i: u64)
	41: Branch(13)
B4:
	42: MoveLoc[0](validators: &vector<Validator>)
	43: Pop
	44: MoveLoc[7](staking_reward_amounts: vector<u64>)
	45: MoveLoc[8](storage_fund_reward_amounts: vector<u64>)
	46: Ret
}
contains_duplicate_validator(validators: &vector<Validator>, new_validator: &Validator): bool {
B0:
	0: CopyLoc[0](validators: &vector<Validator>)
	1: VecLen(42)
	2: StLoc[3](len: u64)
	3: LdU64(0)
	4: StLoc[2](i: u64)
B1:
	5: CopyLoc[2](i: u64)
	6: CopyLoc[3](len: u64)
	7: Lt
	8: BrFalse(27)
B2:
	9: Branch(10)
B3:
	10: CopyLoc[0](validators: &vector<Validator>)
	11: CopyLoc[2](i: u64)
	12: VecImmBorrow(42)
	13: CopyLoc[1](new_validator: &Validator)
	14: Call validator::is_duplicate(&Validator, &Validator): bool
	15: BrFalse(22)
B4:
	16: MoveLoc[0](validators: &vector<Validator>)
	17: Pop
	18: MoveLoc[1](new_validator: &Validator)
	19: Pop
	20: LdTrue
	21: Ret
B5:
	22: MoveLoc[2](i: u64)
	23: LdU64(1)
	24: Add
	25: StLoc[2](i: u64)
	26: Branch(5)
B6:
	27: MoveLoc[0](validators: &vector<Validator>)
	28: Pop
	29: MoveLoc[1](new_validator: &Validator)
	30: Pop
	31: LdFalse
	32: Ret
}
derive_next_epoch_validators(self: &ValidatorSet): vector<ValidatorMetadata> {
L0:	i: u64
L1:	metadata: &ValidatorMetadata
L2:	metadata#1: &ValidatorMetadata
L3:	pending_count: u64
L4:	removal_count: u64
L5:	result: vector<ValidatorMetadata>
B0:
	0: CopyLoc[0](self: &ValidatorSet)
	1: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	2: VecLen(42)
	3: StLoc[1](active_count: u64)
	4: CopyLoc[0](self: &ValidatorSet)
	5: ImmBorrowField[5](ValidatorSet.pending_removals: vector<u64>)
	6: VecLen(17)
	7: StLoc[6](removal_count: u64)
	8: VecPack(67, 0)
	9: StLoc[7](result: vector<ValidatorMetadata>)
B1:
	10: CopyLoc[1](active_count: u64)
	11: LdU64(0)
	12: Gt
	13: BrFalse(57)
B2:
	14: Branch(15)
B3:
	15: CopyLoc[6](removal_count: u64)
	16: LdU64(0)
	17: Gt
	18: BrFalse(40)
B4:
	19: CopyLoc[0](self: &ValidatorSet)
	20: ImmBorrowField[5](ValidatorSet.pending_removals: vector<u64>)
	21: CopyLoc[6](removal_count: u64)
	22: LdU64(1)
	23: Sub
	24: VecImmBorrow(17)
	25: ReadRef
	26: CopyLoc[1](active_count: u64)
	27: LdU64(1)
	28: Sub
	29: Eq
	30: BrFalse(40)
B5:
	31: MoveLoc[6](removal_count: u64)
	32: LdU64(1)
	33: Sub
	34: StLoc[6](removal_count: u64)
	35: MoveLoc[1](active_count: u64)
	36: LdU64(1)
	37: Sub
	38: StLoc[1](active_count: u64)
	39: Branch(10)
B6:
	40: CopyLoc[0](self: &ValidatorSet)
	41: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	42: CopyLoc[1](active_count: u64)
	43: LdU64(1)
	44: Sub
	45: VecImmBorrow(42)
	46: Call validator::metadata(&Validator): &ValidatorMetadata
	47: StLoc[3](metadata: &ValidatorMetadata)
	48: MutBorrowLoc[7](result: vector<ValidatorMetadata>)
	49: MoveLoc[3](metadata: &ValidatorMetadata)
	50: ReadRef
	51: VecPushBack(67)
	52: MoveLoc[1](active_count: u64)
	53: LdU64(1)
	54: Sub
	55: StLoc[1](active_count: u64)
	56: Branch(10)
B7:
	57: LdU64(0)
	58: StLoc[2](i: u64)
	59: CopyLoc[0](self: &ValidatorSet)
	60: ImmBorrowField[3](ValidatorSet.pending_validators: vector<Validator>)
	61: VecLen(42)
	62: StLoc[5](pending_count: u64)
B8:
	63: CopyLoc[2](i: u64)
	64: CopyLoc[5](pending_count: u64)
	65: Lt
	66: BrFalse(83)
B9:
	67: Branch(68)
B10:
	68: CopyLoc[0](self: &ValidatorSet)
	69: ImmBorrowField[3](ValidatorSet.pending_validators: vector<Validator>)
	70: CopyLoc[2](i: u64)
	71: VecImmBorrow(42)
	72: Call validator::metadata(&Validator): &ValidatorMetadata
	73: StLoc[4](metadata#1: &ValidatorMetadata)
	74: MutBorrowLoc[7](result: vector<ValidatorMetadata>)
	75: MoveLoc[4](metadata#1: &ValidatorMetadata)
	76: ReadRef
	77: VecPushBack(67)
	78: MoveLoc[2](i: u64)
	79: LdU64(1)
	80: Add
	81: StLoc[2](i: u64)
	82: Branch(63)
B11:
	83: MoveLoc[0](self: &ValidatorSet)
	84: Pop
	85: MoveLoc[7](result: vector<ValidatorMetadata>)
	86: Ret
}
public derive_reference_gas_price(self: &ValidatorSet): u64 {
L0:	i: u64
L1:	num_validators: u64
L2:	pq: PriorityQueue<u64>
L3:	result: u64
L4:	stake: u64
L5:	sum: u64
L6:	threshold: u64
L7:	v: &Validator
L8:	vs: &vector<Validator>
B0:
	0: MoveLoc[0](self: &ValidatorSet)
	1: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	2: StLoc[10](vs: &vector<Validator>)
	3: CopyLoc[10](vs: &vector<Validator>)
	4: VecLen(42)
	5: StLoc[3](num_validators: u64)
	6: VecPack(70, 0)
	7: StLoc[1](entries: vector<Entry<u64>>)
	8: LdU64(0)
	9: StLoc[2](i: u64)
B1:
	10: CopyLoc[2](i: u64)
	11: CopyLoc[3](num_validators: u64)
	12: Lt
	13: BrFalse(31)
B2:
	14: Branch(15)
B3:
	15: CopyLoc[10](vs: &vector<Validator>)
	16: CopyLoc[2](i: u64)
	17: VecImmBorrow(42)
	18: StLoc[9](v: &Validator)
	19: MutBorrowLoc[1](entries: vector<Entry<u64>>)
	20: CopyLoc[9](v: &Validator)
	21: Call validator::gas_price(&Validator): u64
	22: MoveLoc[9](v: &Validator)
	23: Call validator::voting_power(&Validator): u64
	24: Call priority_queue::new_entry<u64>(u64, u64): Entry<u64>
	25: VecPushBack(70)
	26: MoveLoc[2](i: u64)
	27: LdU64(1)
	28: Add
	29: StLoc[2](i: u64)
	30: Branch(10)
B4:
	31: MoveLoc[10](vs: &vector<Validator>)
	32: Pop
	33: MoveLoc[1](entries: vector<Entry<u64>>)
	34: Call priority_queue::new<u64>(vector<Entry<u64>>): PriorityQueue<u64>
	35: StLoc[4](pq: PriorityQueue<u64>)
	36: LdU64(0)
	37: StLoc[7](sum: u64)
	38: Call voting_power::total_voting_power(): u64
	39: Call voting_power::quorum_threshold(): u64
	40: Sub
	41: StLoc[8](threshold: u64)
	42: LdU64(0)
	43: StLoc[5](result: u64)
B5:
	44: CopyLoc[7](sum: u64)
	45: CopyLoc[8](threshold: u64)
	46: Lt
	47: BrFalse(58)
B6:
	48: Branch(49)
B7:
	49: MutBorrowLoc[4](pq: PriorityQueue<u64>)
	50: Call priority_queue::pop_max<u64>(&mut PriorityQueue<u64>): u64 * u64
	51: StLoc[6](stake: u64)
	52: StLoc[5](result: u64)
	53: MoveLoc[7](sum: u64)
	54: MoveLoc[6](stake: u64)
	55: Add
	56: StLoc[7](sum: u64)
	57: Branch(44)
B8:
	58: MoveLoc[5](result: u64)
	59: Ret
}
distribute_reward(validators: &mut vector<Validator>, adjusted_staking_reward_amounts: &vector<u64>, adjusted_storage_fund_reward_amounts: &vector<u64>, staking_rewards: &mut Balance<SUI>, storage_fund_reward: &mut Balance<SUI>, ctx: &mut TxContext) {
L0:	self_stake: u64
L1:	staking_reward_amount: u64
L2:	validator: &mut Validator
L3:	validator_reward: Balance<SUI>
L4:	validator_reward_amount: u128
B0:
	0: CopyLoc[0](validators: &mut vector<Validator>)
	1: FreezeRef
	2: VecLen(42)
	3: StLoc[11](length: u64)
	4: CopyLoc[11](length: u64)
	5: LdU64(0)
	6: Gt
	7: BrFalse(9)
B1:
	8: Branch(23)
B2:
	9: MoveLoc[0](validators: &mut vector<Validator>)
	10: Pop
	11: MoveLoc[4](storage_fund_reward: &mut Balance<SUI>)
	12: Pop
	13: MoveLoc[3](staking_rewards: &mut Balance<SUI>)
	14: Pop
	15: MoveLoc[5](ctx: &mut TxContext)
	16: Pop
	17: MoveLoc[2](adjusted_storage_fund_reward_amounts: &vector<u64>)
	18: Pop
	19: MoveLoc[1](adjusted_staking_reward_amounts: &vector<u64>)
	20: Pop
	21: LdU64(0)
	22: Abort
B3:
	23: LdU64(0)
	24: StLoc[10](i: u64)
B4:
	25: CopyLoc[10](i: u64)
	26: CopyLoc[11](length: u64)
	27: Lt
	28: BrFalse(109)
B5:
	29: Branch(30)
B6:
	30: CopyLoc[0](validators: &mut vector<Validator>)
	31: CopyLoc[10](i: u64)
	32: VecMutBorrow(42)
	33: StLoc[14](validator: &mut Validator)
	34: CopyLoc[1](adjusted_staking_reward_amounts: &vector<u64>)
	35: CopyLoc[10](i: u64)
	36: VecImmBorrow(17)
	37: ReadRef
	38: StLoc[13](staking_reward_amount: u64)
	39: CopyLoc[14](validator: &mut Validator)
	40: FreezeRef
	41: Call validator::total_stake_amount(&Validator): u64
	42: StLoc[6](combined_stake: u64)
	43: CopyLoc[14](validator: &mut Validator)
	44: FreezeRef
	45: Call validator::stake_amount(&Validator): u64
	46: StLoc[12](self_stake: u64)
	47: CopyLoc[13](staking_reward_amount: u64)
	48: CastU128
	49: MoveLoc[12](self_stake: u64)
	50: CastU128
	51: Mul
	52: MoveLoc[6](combined_stake: u64)
	53: CastU128
	54: Div
	55: StLoc[16](validator_reward_amount: u128)
	56: CopyLoc[3](staking_rewards: &mut Balance<SUI>)
	57: CopyLoc[16](validator_reward_amount: u128)
	58: CastU64
	59: Call balance::split<SUI>(&mut Balance<SUI>, u64): Balance<SUI>
	60: StLoc[15](validator_reward: Balance<SUI>)
	61: MoveLoc[13](staking_reward_amount: u64)
	62: MoveLoc[16](validator_reward_amount: u128)
	63: CastU64
	64: Sub
	65: StLoc[9](delegator_reward_amount: u64)
	66: CopyLoc[3](staking_rewards: &mut Balance<SUI>)
	67: CopyLoc[9](delegator_reward_amount: u64)
	68: Call balance::split<SUI>(&mut Balance<SUI>, u64): Balance<SUI>
	69: StLoc[8](delegator_reward: Balance<SUI>)
	70: MoveLoc[9](delegator_reward_amount: u64)
	71: CastU128
	72: CopyLoc[14](validator: &mut Validator)
	73: FreezeRef
	74: Call validator::commission_rate(&Validator): u64
	75: CastU128
	76: Mul
	77: LdConst[0](U128: [16, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
	78: Div
	79: StLoc[7](commission_amount: u128)
	80: MutBorrowLoc[15](validator_reward: Balance<SUI>)
	81: MutBorrowLoc[8](delegator_reward: Balance<SUI>)
	82: MoveLoc[7](commission_amount: u128)
	83: CastU64
	84: Call balance::split<SUI>(&mut Balance<SUI>, u64): Balance<SUI>
	85: Call balance::join<SUI>(&mut Balance<SUI>, Balance<SUI>): u64
	86: Pop
	87: MutBorrowLoc[15](validator_reward: Balance<SUI>)
	88: CopyLoc[4](storage_fund_reward: &mut Balance<SUI>)
	89: CopyLoc[2](adjusted_storage_fund_reward_amounts: &vector<u64>)
	90: CopyLoc[10](i: u64)
	91: VecImmBorrow(17)
	92: ReadRef
	93: Call balance::split<SUI>(&mut Balance<SUI>, u64): Balance<SUI>
	94: Call balance::join<SUI>(&mut Balance<SUI>, Balance<SUI>): u64
	95: Pop
	96: CopyLoc[14](validator: &mut Validator)
	97: MoveLoc[15](validator_reward: Balance<SUI>)
	98: Call option::none<EpochTimeLock>(): Option<EpochTimeLock>
	99: CopyLoc[5](ctx: &mut TxContext)
	100: Call validator::request_add_stake(&mut Validator, Balance<SUI>, Option<EpochTimeLock>, &mut TxContext)
	101: MoveLoc[14](validator: &mut Validator)
	102: MoveLoc[8](delegator_reward: Balance<SUI>)
	103: Call validator::deposit_delegation_rewards(&mut Validator, Balance<SUI>)
	104: MoveLoc[10](i: u64)
	105: LdU64(1)
	106: Add
	107: StLoc[10](i: u64)
	108: Branch(25)
B7:
	109: MoveLoc[0](validators: &mut vector<Validator>)
	110: Pop
	111: MoveLoc[4](storage_fund_reward: &mut Balance<SUI>)
	112: Pop
	113: MoveLoc[3](staking_rewards: &mut Balance<SUI>)
	114: Pop
	115: MoveLoc[5](ctx: &mut TxContext)
	116: Pop
	117: MoveLoc[2](adjusted_storage_fund_reward_amounts: &vector<u64>)
	118: Pop
	119: MoveLoc[1](adjusted_staking_reward_amounts: &vector<u64>)
	120: Pop
	121: Ret
}
emit_validator_epoch_events(new_epoch: u64, vs: &vector<Validator>, reward_amounts: &vector<u64>, report_records: &VecMap<address, VecSet<address>>, slashed_validators: &vector<address>) {
L0:	tallying_rule_reporters: vector<address>
L1:	v: &Validator
L2:	validator_address: address
B0:
	0: CopyLoc[1](vs: &vector<Validator>)
	1: VecLen(42)
	2: StLoc[8](num_validators: u64)
	3: LdU64(0)
	4: StLoc[7](i: u64)
B1:
	5: CopyLoc[7](i: u64)
	6: CopyLoc[8](num_validators: u64)
	7: Lt
	8: BrFalse(68)
B2:
	9: Branch(10)
B3:
	10: CopyLoc[1](vs: &vector<Validator>)
	11: CopyLoc[7](i: u64)
	12: VecImmBorrow(42)
	13: StLoc[11](v: &Validator)
	14: CopyLoc[11](v: &Validator)
	15: Call validator::sui_address(&Validator): address
	16: StLoc[12](validator_address: address)
	17: CopyLoc[3](report_records: &VecMap<address, VecSet<address>>)
	18: ImmBorrowLoc[12](validator_address: address)
	19: Call vec_map::contains<address, VecSet<address>>(&VecMap<address, VecSet<address>>, &address): bool
	20: BrFalse(28)
B4:
	21: CopyLoc[3](report_records: &VecMap<address, VecSet<address>>)
	22: ImmBorrowLoc[12](validator_address: address)
	23: Call vec_map::get<address, VecSet<address>>(&VecMap<address, VecSet<address>>, &address): &VecSet<address>
	24: ReadRef
	25: Call vec_set::into_keys<address>(VecSet<address>): vector<address>
	26: StLoc[5](%#1: vector<address>)
	27: Branch(30)
B5:
	28: LdConst[3](Vector(Address): [0])
	29: StLoc[5](%#1: vector<address>)
B6:
	30: MoveLoc[5](%#1: vector<address>)
	31: StLoc[10](tallying_rule_reporters: vector<address>)
	32: CopyLoc[4](slashed_validators: &vector<address>)
	33: ImmBorrowLoc[12](validator_address: address)
	34: Call vector::contains<address>(&vector<address>, &address): bool
	35: BrFalse(39)
B7:
	36: LdU64(0)
	37: StLoc[6](%#2: u64)
	38: Branch(41)
B8:
	39: LdU64(1)
	40: StLoc[6](%#2: u64)
B9:
	41: MoveLoc[6](%#2: u64)
	42: StLoc[9](tallying_rule_global_score: u64)
	43: CopyLoc[0](new_epoch: u64)
	44: MoveLoc[12](validator_address: address)
	45: CopyLoc[11](v: &Validator)
	46: Call validator::gas_price(&Validator): u64
	47: CopyLoc[11](v: &Validator)
	48: Call validator::stake_amount(&Validator): u64
	49: CopyLoc[11](v: &Validator)
	50: Call validator::delegate_amount(&Validator): u64
	51: CopyLoc[11](v: &Validator)
	52: Call validator::commission_rate(&Validator): u64
	53: CopyLoc[2](reward_amounts: &vector<u64>)
	54: CopyLoc[7](i: u64)
	55: VecImmBorrow(17)
	56: ReadRef
	57: MoveLoc[11](v: &Validator)
	58: Call validator::pool_token_exchange_rate(&Validator): PoolTokenExchangeRate
	59: MoveLoc[10](tallying_rule_reporters: vector<address>)
	60: MoveLoc[9](tallying_rule_global_score: u64)
	61: Pack[1](ValidatorEpochInfo)
	62: Call event::emit<ValidatorEpochInfo>(ValidatorEpochInfo)
	63: MoveLoc[7](i: u64)
	64: LdU64(1)
	65: Add
	66: StLoc[7](i: u64)
	67: Branch(5)
B10:
	68: MoveLoc[1](vs: &vector<Validator>)
	69: Pop
	70: MoveLoc[4](slashed_validators: &vector<address>)
	71: Pop
	72: MoveLoc[2](reward_amounts: &vector<u64>)
	73: Pop
	74: MoveLoc[3](report_records: &VecMap<address, VecSet<address>>)
	75: Pop
	76: Ret
}
find_validator(validators: &vector<Validator>, validator_address: address): Option<u64> {
B0:
	0: CopyLoc[0](validators: &vector<Validator>)
	1: VecLen(42)
	2: StLoc[3](length: u64)
	3: LdU64(0)
	4: StLoc[2](i: u64)
B1:
	5: CopyLoc[2](i: u64)
	6: CopyLoc[3](length: u64)
	7: Lt
	8: BrFalse(27)
B2:
	9: Branch(10)
B3:
	10: CopyLoc[0](validators: &vector<Validator>)
	11: CopyLoc[2](i: u64)
	12: VecImmBorrow(42)
	13: Call validator::sui_address(&Validator): address
	14: CopyLoc[1](validator_address: address)
	15: Eq
	16: BrFalse(22)
B4:
	17: MoveLoc[0](validators: &vector<Validator>)
	18: Pop
	19: MoveLoc[2](i: u64)
	20: Call option::some<u64>(u64): Option<u64>
	21: Ret
B5:
	22: MoveLoc[2](i: u64)
	23: LdU64(1)
	24: Add
	25: StLoc[2](i: u64)
	26: Branch(5)
B6:
	27: MoveLoc[0](validators: &vector<Validator>)
	28: Pop
	29: Call option::none<u64>(): Option<u64>
	30: Ret
}
get_validator_indices(validators: &vector<Validator>, validator_addresses: &vector<address>): vector<u64> {
L0:	index_opt: Option<u64>
L1:	length: u64
L2:	res: vector<u64>
B0:
	0: CopyLoc[1](validator_addresses: &vector<address>)
	1: VecLen(47)
	2: StLoc[5](length: u64)
	3: LdU64(0)
	4: StLoc[3](i: u64)
	5: LdConst[4](Vector(U64): [0])
	6: StLoc[6](res: vector<u64>)
B1:
	7: CopyLoc[3](i: u64)
	8: CopyLoc[5](length: u64)
	9: Lt
	10: BrFalse(40)
B2:
	11: Branch(12)
B3:
	12: CopyLoc[1](validator_addresses: &vector<address>)
	13: CopyLoc[3](i: u64)
	14: VecImmBorrow(47)
	15: ReadRef
	16: StLoc[2](addr: address)
	17: CopyLoc[0](validators: &vector<Validator>)
	18: MoveLoc[2](addr: address)
	19: Call find_validator(&vector<Validator>, address): Option<u64>
	20: StLoc[4](index_opt: Option<u64>)
	21: ImmBorrowLoc[4](index_opt: Option<u64>)
	22: Call option::is_some<u64>(&Option<u64>): bool
	23: BrFalse(25)
B4:
	24: Branch(31)
B5:
	25: MoveLoc[0](validators: &vector<Validator>)
	26: Pop
	27: MoveLoc[1](validator_addresses: &vector<address>)
	28: Pop
	29: LdU64(0)
	30: Abort
B6:
	31: MutBorrowLoc[6](res: vector<u64>)
	32: MoveLoc[4](index_opt: Option<u64>)
	33: Call option::destroy_some<u64>(Option<u64>): u64
	34: VecPushBack(17)
	35: MoveLoc[3](i: u64)
	36: LdU64(1)
	37: Add
	38: StLoc[3](i: u64)
	39: Branch(7)
B7:
	40: MoveLoc[0](validators: &vector<Validator>)
	41: Pop
	42: MoveLoc[1](validator_addresses: &vector<address>)
	43: Pop
	44: MoveLoc[6](res: vector<u64>)
	45: Ret
}
get_validator_mut(validators: &mut vector<Validator>, validator_address: address): &mut Validator {
L0:	validator_index_opt: Option<u64>
B0:
	0: CopyLoc[0](validators: &mut vector<Validator>)
	1: MoveLoc[1](validator_address: address)
	2: StLoc[2](%#2: address)
	3: FreezeRef
	4: MoveLoc[2](%#2: address)
	5: Call find_validator(&vector<Validator>, address): Option<u64>
	6: StLoc[4](validator_index_opt: Option<u64>)
	7: ImmBorrowLoc[4](validator_index_opt: Option<u64>)
	8: Call option::is_some<u64>(&Option<u64>): bool
	9: BrFalse(11)
B1:
	10: Branch(15)
B2:
	11: MoveLoc[0](validators: &mut vector<Validator>)
	12: Pop
	13: LdU64(0)
	14: Abort
B3:
	15: MutBorrowLoc[4](validator_index_opt: Option<u64>)
	16: Call option::extract<u64>(&mut Option<u64>): u64
	17: StLoc[3](validator_index: u64)
	18: MoveLoc[0](validators: &mut vector<Validator>)
	19: MoveLoc[3](validator_index: u64)
	20: VecMutBorrow(42)
	21: Ret
}
get_validator_ref(validators: &vector<Validator>, validator_address: address): &Validator {
B0:
	0: CopyLoc[0](validators: &vector<Validator>)
	1: MoveLoc[1](validator_address: address)
	2: Call find_validator(&vector<Validator>, address): Option<u64>
	3: StLoc[3](validator_index_opt: Option<u64>)
	4: ImmBorrowLoc[3](validator_index_opt: Option<u64>)
	5: Call option::is_some<u64>(&Option<u64>): bool
	6: BrFalse(8)
B1:
	7: Branch(12)
B2:
	8: MoveLoc[0](validators: &vector<Validator>)
	9: Pop
	10: LdU64(0)
	11: Abort
B3:
	12: MutBorrowLoc[3](validator_index_opt: Option<u64>)
	13: Call option::extract<u64>(&mut Option<u64>): u64
	14: StLoc[2](validator_index: u64)
	15: MoveLoc[0](validators: &vector<Validator>)
	16: MoveLoc[2](validator_index: u64)
	17: VecImmBorrow(42)
	18: Ret
}
public(friend) is_active_validator(self: &ValidatorSet, validator_address: address): bool {
B0:
	0: MoveLoc[0](self: &ValidatorSet)
	1: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	2: MoveLoc[1](validator_address: address)
	3: Call find_validator(&vector<Validator>, address): Option<u64>
	4: StLoc[2](%#1: Option<u64>)
	5: ImmBorrowLoc[2](%#1: Option<u64>)
	6: Call option::is_some<u64>(&Option<u64>): bool
	7: Ret
}
public(friend) new(init_active_validators: vector<Validator>): ValidatorSet {
B0:
	0: ImmBorrowLoc[0](init_active_validators: vector<Validator>)
	1: Call calculate_total_stakes(&vector<Validator>): u64 * u64
	2: MoveLoc[0](init_active_validators: vector<Validator>)
	3: VecPack(42, 0)
	4: VecPack(17, 0)
	5: VecPack(67, 0)
	6: Call vec_map::empty<ValidatorPair, TableVec<PendingWithdrawEntry>>(): VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>
	7: Pack[3](ValidatorSet)
	8: StLoc[1](validators: ValidatorSet)
	9: ImmBorrowLoc[1](validators: ValidatorSet)
	10: Call derive_next_epoch_validators(&ValidatorSet): vector<ValidatorMetadata>
	11: MutBorrowLoc[1](validators: ValidatorSet)
	12: MutBorrowField[4](ValidatorSet.next_epoch_validators: vector<ValidatorMetadata>)
	13: WriteRef
	14: MutBorrowLoc[1](validators: ValidatorSet)
	15: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	16: Call voting_power::set_voting_power(&mut vector<Validator>)
	17: MoveLoc[1](validators: ValidatorSet)
	18: Ret
}
public(friend) next_epoch_validator_count(self: &ValidatorSet): u64 {
B0:
	0: MoveLoc[0](self: &ValidatorSet)
	1: ImmBorrowField[4](ValidatorSet.next_epoch_validators: vector<ValidatorMetadata>)
	2: VecLen(67)
	3: Ret
}
process_pending_delegation_switches(self: &mut ValidatorSet, ctx: &mut TxContext) {
L0:	entries: TableVec<PendingWithdrawEntry>
L1:	from: address
L2:	from_validator: &mut Validator
L3:	new_stake: Balance<SUI>
L4:	rewards: vector<Balance<SUI>>
L5:	rewards_withdraw_amount: u64
L6:	to: address
L7:	to_validator: &mut Validator
B0:
	0: CopyLoc[0](self: &mut ValidatorSet)
	1: ImmBorrowField[6](ValidatorSet.pending_delegation_switches: VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>)
	2: Call vec_map::is_empty<ValidatorPair, TableVec<PendingWithdrawEntry>>(&VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>): bool
	3: Not
	4: BrFalse(77)
B1:
	5: Branch(6)
B2:
	6: CopyLoc[0](self: &mut ValidatorSet)
	7: MutBorrowField[6](ValidatorSet.pending_delegation_switches: VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>)
	8: Call vec_map::pop<ValidatorPair, TableVec<PendingWithdrawEntry>>(&mut VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>): ValidatorPair * TableVec<PendingWithdrawEntry>
	9: StLoc[4](entries: TableVec<PendingWithdrawEntry>)
	10: Unpack[2](ValidatorPair)
	11: StLoc[10](to: address)
	12: StLoc[5](from: address)
	13: CopyLoc[0](self: &mut ValidatorSet)
	14: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	15: MoveLoc[5](from: address)
	16: Call get_validator_mut(&mut vector<Validator>, address): &mut Validator
	17: StLoc[6](from_validator: &mut Validator)
	18: CopyLoc[6](from_validator: &mut Validator)
	19: Call validator::get_staking_pool_mut_ref(&mut Validator): &mut StakingPool
	20: MoveLoc[4](entries: TableVec<PendingWithdrawEntry>)
	21: Call staking_pool::batch_withdraw_rewards_and_burn_pool_tokens(&mut StakingPool, TableVec<PendingWithdrawEntry>): vector<address> * vector<Balance<SUI>> * u64
	22: StLoc[9](rewards_withdraw_amount: u64)
	23: StLoc[8](rewards: vector<Balance<SUI>>)
	24: StLoc[3](delegators: vector<address>)
	25: MoveLoc[6](from_validator: &mut Validator)
	26: MoveLoc[9](rewards_withdraw_amount: u64)
	27: Call validator::decrease_next_epoch_delegation(&mut Validator, u64)
	28: ImmBorrowLoc[3](delegators: vector<address>)
	29: VecLen(47)
	30: ImmBorrowLoc[8](rewards: vector<Balance<SUI>>)
	31: VecLen(100)
	32: Eq
	33: BrFalse(35)
B3:
	34: Branch(41)
B4:
	35: MoveLoc[0](self: &mut ValidatorSet)
	36: Pop
	37: MoveLoc[1](ctx: &mut TxContext)
	38: Pop
	39: LdU64(0)
	40: Abort
B5:
	41: CopyLoc[0](self: &mut ValidatorSet)
	42: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	43: MoveLoc[10](to: address)
	44: Call get_validator_mut(&mut vector<Validator>, address): &mut Validator
	45: StLoc[11](to_validator: &mut Validator)
B6:
	46: ImmBorrowLoc[8](rewards: vector<Balance<SUI>>)
	47: Call vector::is_empty<Balance<SUI>>(&vector<Balance<SUI>>): bool
	48: Not
	49: BrFalse(72)
B7:
	50: Branch(51)
B8:
	51: MutBorrowLoc[3](delegators: vector<address>)
	52: VecPopBack(47)
	53: StLoc[2](delegator: address)
	54: MutBorrowLoc[8](rewards: vector<Balance<SUI>>)
	55: VecPopBack(100)
	56: StLoc[7](new_stake: Balance<SUI>)
	57: ImmBorrowLoc[7](new_stake: Balance<SUI>)
	58: Call balance::value<SUI>(&Balance<SUI>): u64
	59: LdU64(0)
	60: Eq
	61: BrFalse(65)
B9:
	62: MoveLoc[7](new_stake: Balance<SUI>)
	63: Call balance::destroy_zero<SUI>(Balance<SUI>)
	64: Branch(71)
B10:
	65: CopyLoc[11](to_validator: &mut Validator)
	66: MoveLoc[7](new_stake: Balance<SUI>)
	67: Call option::none<EpochTimeLock>(): Option<EpochTimeLock>
	68: MoveLoc[2](delegator: address)
	69: CopyLoc[1](ctx: &mut TxContext)
	70: Call validator::request_add_delegation(&mut Validator, Balance<SUI>, Option<EpochTimeLock>, address, &mut TxContext)
B11:
	71: Branch(46)
B12:
	72: MoveLoc[11](to_validator: &mut Validator)
	73: Pop
	74: MoveLoc[8](rewards: vector<Balance<SUI>>)
	75: VecUnpack(100, 0)
	76: Branch(0)
B13:
	77: MoveLoc[0](self: &mut ValidatorSet)
	78: Pop
	79: MoveLoc[1](ctx: &mut TxContext)
	80: Pop
	81: Ret
}
process_pending_delegations_and_withdraws(validators: &mut vector<Validator>, ctx: &mut TxContext) {
B0:
	0: CopyLoc[0](validators: &mut vector<Validator>)
	1: FreezeRef
	2: VecLen(42)
	3: StLoc[3](length: u64)
	4: LdU64(0)
	5: StLoc[2](i: u64)
B1:
	6: CopyLoc[2](i: u64)
	7: CopyLoc[3](length: u64)
	8: Lt
	9: BrFalse(21)
B2:
	10: Branch(11)
B3:
	11: CopyLoc[0](validators: &mut vector<Validator>)
	12: CopyLoc[2](i: u64)
	13: VecMutBorrow(42)
	14: CopyLoc[1](ctx: &mut TxContext)
	15: Call validator::process_pending_delegations_and_withdraws(&mut Validator, &mut TxContext)
	16: MoveLoc[2](i: u64)
	17: LdU64(1)
	18: Add
	19: StLoc[2](i: u64)
	20: Branch(6)
B4:
	21: MoveLoc[0](validators: &mut vector<Validator>)
	22: Pop
	23: MoveLoc[1](ctx: &mut TxContext)
	24: Pop
	25: Ret
}
process_pending_removals(self: &mut ValidatorSet, ctx: &mut TxContext) {
B0:
	0: CopyLoc[0](self: &mut ValidatorSet)
	1: MutBorrowField[5](ValidatorSet.pending_removals: vector<u64>)
	2: Call sort_removal_list(&mut vector<u64>)
B1:
	3: CopyLoc[0](self: &mut ValidatorSet)
	4: ImmBorrowField[5](ValidatorSet.pending_removals: vector<u64>)
	5: Call vector::is_empty<u64>(&vector<u64>): bool
	6: Not
	7: BrFalse(31)
B2:
	8: Branch(9)
B3:
	9: CopyLoc[0](self: &mut ValidatorSet)
	10: MutBorrowField[5](ValidatorSet.pending_removals: vector<u64>)
	11: VecPopBack(17)
	12: StLoc[2](index: u64)
	13: CopyLoc[0](self: &mut ValidatorSet)
	14: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	15: MoveLoc[2](index: u64)
	16: Call vector::remove<Validator>(&mut vector<Validator>, u64): Validator
	17: StLoc[3](validator: Validator)
	18: CopyLoc[0](self: &mut ValidatorSet)
	19: ImmBorrowField[2](ValidatorSet.total_delegation_stake: u64)
	20: ReadRef
	21: ImmBorrowLoc[3](validator: Validator)
	22: Call validator::delegate_amount(&Validator): u64
	23: Sub
	24: CopyLoc[0](self: &mut ValidatorSet)
	25: MutBorrowField[2](ValidatorSet.total_delegation_stake: u64)
	26: WriteRef
	27: MoveLoc[3](validator: Validator)
	28: CopyLoc[1](ctx: &mut TxContext)
	29: Call validator::destroy(Validator, &mut TxContext)
	30: Branch(3)
B4:
	31: MoveLoc[0](self: &mut ValidatorSet)
	32: Pop
	33: MoveLoc[1](ctx: &mut TxContext)
	34: Pop
	35: Ret
}
process_pending_validators(validators: &mut vector<Validator>, pending_validators: &mut vector<Validator>) {
B0:
	0: CopyLoc[1](pending_validators: &mut vector<Validator>)
	1: FreezeRef
	2: Call vector::is_empty<Validator>(&vector<Validator>): bool
	3: Not
	4: BrFalse(13)
B1:
	5: Branch(6)
B2:
	6: CopyLoc[1](pending_validators: &mut vector<Validator>)
	7: VecPopBack(42)
	8: StLoc[2](v: Validator)
	9: CopyLoc[0](validators: &mut vector<Validator>)
	10: MoveLoc[2](v: Validator)
	11: VecPushBack(42)
	12: Branch(0)
B3:
	13: MoveLoc[0](validators: &mut vector<Validator>)
	14: Pop
	15: MoveLoc[1](pending_validators: &mut vector<Validator>)
	16: Pop
	17: Ret
}
public(friend) request_add_delegation(self: &mut ValidatorSet, validator_address: address, delegated_stake: Balance<SUI>, locking_period: Option<EpochTimeLock>, ctx: &mut TxContext) {
B0:
	0: CopyLoc[0](self: &mut ValidatorSet)
	1: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	2: CopyLoc[1](validator_address: address)
	3: Call get_validator_mut(&mut vector<Validator>, address): &mut Validator
	4: StLoc[7](validator: &mut Validator)
	5: CopyLoc[4](ctx: &mut TxContext)
	6: FreezeRef
	7: Call tx_context::sender(&TxContext): address
	8: StLoc[6](delegator_address: address)
	9: ImmBorrowLoc[2](delegated_stake: Balance<SUI>)
	10: Call balance::value<SUI>(&Balance<SUI>): u64
	11: StLoc[5](amount: u64)
	12: MoveLoc[7](validator: &mut Validator)
	13: MoveLoc[2](delegated_stake: Balance<SUI>)
	14: MoveLoc[3](locking_period: Option<EpochTimeLock>)
	15: CopyLoc[4](ctx: &mut TxContext)
	16: FreezeRef
	17: Call tx_context::sender(&TxContext): address
	18: CopyLoc[4](ctx: &mut TxContext)
	19: Call validator::request_add_delegation(&mut Validator, Balance<SUI>, Option<EpochTimeLock>, address, &mut TxContext)
	20: CopyLoc[0](self: &mut ValidatorSet)
	21: FreezeRef
	22: Call derive_next_epoch_validators(&ValidatorSet): vector<ValidatorMetadata>
	23: MoveLoc[0](self: &mut ValidatorSet)
	24: MutBorrowField[4](ValidatorSet.next_epoch_validators: vector<ValidatorMetadata>)
	25: WriteRef
	26: MoveLoc[1](validator_address: address)
	27: MoveLoc[6](delegator_address: address)
	28: MoveLoc[4](ctx: &mut TxContext)
	29: FreezeRef
	30: Call tx_context::epoch(&TxContext): u64
	31: MoveLoc[5](amount: u64)
	32: Pack[0](DelegationRequestEvent)
	33: Call event::emit<DelegationRequestEvent>(DelegationRequestEvent)
	34: Ret
}
public(friend) request_add_stake(self: &mut ValidatorSet, new_stake: Balance<SUI>, coin_locked_until_epoch: Option<EpochTimeLock>, ctx: &mut TxContext) {
B0:
	0: CopyLoc[3](ctx: &mut TxContext)
	1: FreezeRef
	2: Call tx_context::sender(&TxContext): address
	3: StLoc[4](validator_address: address)
	4: CopyLoc[0](self: &mut ValidatorSet)
	5: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	6: MoveLoc[4](validator_address: address)
	7: Call get_validator_mut(&mut vector<Validator>, address): &mut Validator
	8: MoveLoc[1](new_stake: Balance<SUI>)
	9: MoveLoc[2](coin_locked_until_epoch: Option<EpochTimeLock>)
	10: MoveLoc[3](ctx: &mut TxContext)
	11: Call validator::request_add_stake(&mut Validator, Balance<SUI>, Option<EpochTimeLock>, &mut TxContext)
	12: CopyLoc[0](self: &mut ValidatorSet)
	13: FreezeRef
	14: Call derive_next_epoch_validators(&ValidatorSet): vector<ValidatorMetadata>
	15: MoveLoc[0](self: &mut ValidatorSet)
	16: MutBorrowField[4](ValidatorSet.next_epoch_validators: vector<ValidatorMetadata>)
	17: WriteRef
	18: Ret
}
public(friend) request_add_validator(self: &mut ValidatorSet, validator: Validator) {
B0:
	0: CopyLoc[0](self: &mut ValidatorSet)
	1: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	2: ImmBorrowLoc[1](validator: Validator)
	3: Call contains_duplicate_validator(&vector<Validator>, &Validator): bool
	4: Not
	5: BrFalse(13)
B1:
	6: CopyLoc[0](self: &mut ValidatorSet)
	7: ImmBorrowField[3](ValidatorSet.pending_validators: vector<Validator>)
	8: ImmBorrowLoc[1](validator: Validator)
	9: Call contains_duplicate_validator(&vector<Validator>, &Validator): bool
	10: Not
	11: StLoc[2](%#1: bool)
	12: Branch(15)
B2:
	13: LdFalse
	14: StLoc[2](%#1: bool)
B3:
	15: MoveLoc[2](%#1: bool)
	16: BrFalse(18)
B4:
	17: Branch(22)
B5:
	18: MoveLoc[0](self: &mut ValidatorSet)
	19: Pop
	20: LdU64(0)
	21: Abort
B6:
	22: CopyLoc[0](self: &mut ValidatorSet)
	23: MutBorrowField[3](ValidatorSet.pending_validators: vector<Validator>)
	24: MoveLoc[1](validator: Validator)
	25: VecPushBack(42)
	26: CopyLoc[0](self: &mut ValidatorSet)
	27: FreezeRef
	28: Call derive_next_epoch_validators(&ValidatorSet): vector<ValidatorMetadata>
	29: MoveLoc[0](self: &mut ValidatorSet)
	30: MutBorrowField[4](ValidatorSet.next_epoch_validators: vector<ValidatorMetadata>)
	31: WriteRef
	32: Ret
}
public(friend) request_remove_validator(self: &mut ValidatorSet, ctx: &TxContext) {
L0:	validator_index_opt: Option<u64>
B0:
	0: MoveLoc[1](ctx: &TxContext)
	1: Call tx_context::sender(&TxContext): address
	2: StLoc[2](validator_address: address)
	3: CopyLoc[0](self: &mut ValidatorSet)
	4: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	5: MoveLoc[2](validator_address: address)
	6: Call find_validator(&vector<Validator>, address): Option<u64>
	7: StLoc[4](validator_index_opt: Option<u64>)
	8: ImmBorrowLoc[4](validator_index_opt: Option<u64>)
	9: Call option::is_some<u64>(&Option<u64>): bool
	10: BrFalse(12)
B1:
	11: Branch(16)
B2:
	12: MoveLoc[0](self: &mut ValidatorSet)
	13: Pop
	14: LdU64(0)
	15: Abort
B3:
	16: MutBorrowLoc[4](validator_index_opt: Option<u64>)
	17: Call option::extract<u64>(&mut Option<u64>): u64
	18: StLoc[3](validator_index: u64)
	19: CopyLoc[0](self: &mut ValidatorSet)
	20: ImmBorrowField[5](ValidatorSet.pending_removals: vector<u64>)
	21: ImmBorrowLoc[3](validator_index: u64)
	22: Call vector::contains<u64>(&vector<u64>, &u64): bool
	23: Not
	24: BrFalse(26)
B4:
	25: Branch(30)
B5:
	26: MoveLoc[0](self: &mut ValidatorSet)
	27: Pop
	28: LdU64(0)
	29: Abort
B6:
	30: CopyLoc[0](self: &mut ValidatorSet)
	31: MutBorrowField[5](ValidatorSet.pending_removals: vector<u64>)
	32: MoveLoc[3](validator_index: u64)
	33: VecPushBack(17)
	34: CopyLoc[0](self: &mut ValidatorSet)
	35: FreezeRef
	36: Call derive_next_epoch_validators(&ValidatorSet): vector<ValidatorMetadata>
	37: MoveLoc[0](self: &mut ValidatorSet)
	38: MutBorrowField[4](ValidatorSet.next_epoch_validators: vector<ValidatorMetadata>)
	39: WriteRef
	40: Ret
}
public(friend) request_set_commission_rate(self: &mut ValidatorSet, new_commission_rate: u64, ctx: &TxContext) {
B0:
	0: MoveLoc[2](ctx: &TxContext)
	1: Call tx_context::sender(&TxContext): address
	2: StLoc[3](validator_address: address)
	3: MoveLoc[0](self: &mut ValidatorSet)
	4: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	5: MoveLoc[3](validator_address: address)
	6: Call get_validator_mut(&mut vector<Validator>, address): &mut Validator
	7: MoveLoc[1](new_commission_rate: u64)
	8: Call validator::request_set_commission_rate(&mut Validator, u64)
	9: Ret
}
public(friend) request_set_gas_price(self: &mut ValidatorSet, new_gas_price: u64, ctx: &TxContext) {
B0:
	0: MoveLoc[2](ctx: &TxContext)
	1: Call tx_context::sender(&TxContext): address
	2: StLoc[3](validator_address: address)
	3: MoveLoc[0](self: &mut ValidatorSet)
	4: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	5: MoveLoc[3](validator_address: address)
	6: Call get_validator_mut(&mut vector<Validator>, address): &mut Validator
	7: MoveLoc[1](new_gas_price: u64)
	8: Call validator::request_set_gas_price(&mut Validator, u64)
	9: Ret
}
public(friend) request_switch_delegation(self: &mut ValidatorSet, delegation: Delegation, staked_sui: StakedSui, new_validator_address: address, ctx: &mut TxContext) {
L0:	entry: PendingWithdrawEntry
L1:	key: ValidatorPair
L2:	principal_stake: Balance<SUI>
L3:	principal_sui_amount: u64
L4:	time_lock: Option<EpochTimeLock>
B0:
	0: ImmBorrowLoc[2](staked_sui: StakedSui)
	1: Call staking_pool::validator_address(&StakedSui): address
	2: StLoc[7](current_validator_address: address)
	3: CopyLoc[7](current_validator_address: address)
	4: CopyLoc[3](new_validator_address: address)
	5: Neq
	6: BrFalse(8)
B1:
	7: Branch(14)
B2:
	8: MoveLoc[0](self: &mut ValidatorSet)
	9: Pop
	10: MoveLoc[4](ctx: &mut TxContext)
	11: Pop
	12: LdU64(0)
	13: Abort
B3:
	14: CopyLoc[0](self: &mut ValidatorSet)
	15: CopyLoc[3](new_validator_address: address)
	16: StLoc[5](%#2: address)
	17: FreezeRef
	18: MoveLoc[5](%#2: address)
	19: Call is_active_validator(&ValidatorSet, address): bool
	20: BrFalse(22)
B4:
	21: Branch(28)
B5:
	22: MoveLoc[0](self: &mut ValidatorSet)
	23: Pop
	24: MoveLoc[4](ctx: &mut TxContext)
	25: Pop
	26: LdU64(0)
	27: Abort
B6:
	28: CopyLoc[0](self: &mut ValidatorSet)
	29: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	30: CopyLoc[7](current_validator_address: address)
	31: Call get_validator_mut(&mut vector<Validator>, address): &mut Validator
	32: StLoc[6](current_validator: &mut Validator)
	33: CopyLoc[6](current_validator: &mut Validator)
	34: Call validator::get_staking_pool_mut_ref(&mut Validator): &mut StakingPool
	35: MoveLoc[1](delegation: Delegation)
	36: MoveLoc[2](staked_sui: StakedSui)
	37: Call staking_pool::withdraw_from_principal(&mut StakingPool, Delegation, StakedSui): Balance<DelegationToken> * Balance<SUI> * Option<EpochTimeLock>
	38: StLoc[14](time_lock: Option<EpochTimeLock>)
	39: StLoc[12](principal_stake: Balance<SUI>)
	40: StLoc[8](current_validator_pool_token: Balance<DelegationToken>)
	41: ImmBorrowLoc[12](principal_stake: Balance<SUI>)
	42: Call balance::value<SUI>(&Balance<SUI>): u64
	43: StLoc[13](principal_sui_amount: u64)
	44: MoveLoc[6](current_validator: &mut Validator)
	45: CopyLoc[13](principal_sui_amount: u64)
	46: Call validator::decrease_next_epoch_delegation(&mut Validator, u64)
	47: CopyLoc[0](self: &mut ValidatorSet)
	48: CopyLoc[3](new_validator_address: address)
	49: MoveLoc[12](principal_stake: Balance<SUI>)
	50: MoveLoc[14](time_lock: Option<EpochTimeLock>)
	51: CopyLoc[4](ctx: &mut TxContext)
	52: Call request_add_delegation(&mut ValidatorSet, address, Balance<SUI>, Option<EpochTimeLock>, &mut TxContext)
	53: CopyLoc[4](ctx: &mut TxContext)
	54: FreezeRef
	55: Call tx_context::sender(&TxContext): address
	56: StLoc[9](delegator: address)
	57: MoveLoc[7](current_validator_address: address)
	58: MoveLoc[3](new_validator_address: address)
	59: Pack[2](ValidatorPair)
	60: StLoc[11](key: ValidatorPair)
	61: MoveLoc[9](delegator: address)
	62: MoveLoc[13](principal_sui_amount: u64)
	63: MoveLoc[8](current_validator_pool_token: Balance<DelegationToken>)
	64: Call staking_pool::new_pending_withdraw_entry(address, u64, Balance<DelegationToken>): PendingWithdrawEntry
	65: StLoc[10](entry: PendingWithdrawEntry)
	66: CopyLoc[0](self: &mut ValidatorSet)
	67: ImmBorrowField[6](ValidatorSet.pending_delegation_switches: VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>)
	68: ImmBorrowLoc[11](key: ValidatorPair)
	69: Call vec_map::contains<ValidatorPair, TableVec<PendingWithdrawEntry>>(&VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>, &ValidatorPair): bool
	70: Not
	71: BrFalse(80)
B7:
	72: CopyLoc[0](self: &mut ValidatorSet)
	73: MutBorrowField[6](ValidatorSet.pending_delegation_switches: VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>)
	74: MoveLoc[11](key: ValidatorPair)
	75: MoveLoc[10](entry: PendingWithdrawEntry)
	76: MoveLoc[4](ctx: &mut TxContext)
	77: Call table_vec::singleton<PendingWithdrawEntry>(PendingWithdrawEntry, &mut TxContext): TableVec<PendingWithdrawEntry>
	78: Call vec_map::insert<ValidatorPair, TableVec<PendingWithdrawEntry>>(&mut VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>, ValidatorPair, TableVec<PendingWithdrawEntry>)
	79: Branch(88)
B8:
	80: MoveLoc[4](ctx: &mut TxContext)
	81: Pop
	82: CopyLoc[0](self: &mut ValidatorSet)
	83: MutBorrowField[6](ValidatorSet.pending_delegation_switches: VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>)
	84: ImmBorrowLoc[11](key: ValidatorPair)
	85: Call vec_map::get_mut<ValidatorPair, TableVec<PendingWithdrawEntry>>(&mut VecMap<ValidatorPair, TableVec<PendingWithdrawEntry>>, &ValidatorPair): &mut TableVec<PendingWithdrawEntry>
	86: MoveLoc[10](entry: PendingWithdrawEntry)
	87: Call table_vec::push_back<PendingWithdrawEntry>(&mut TableVec<PendingWithdrawEntry>, PendingWithdrawEntry)
B9:
	88: CopyLoc[0](self: &mut ValidatorSet)
	89: FreezeRef
	90: Call derive_next_epoch_validators(&ValidatorSet): vector<ValidatorMetadata>
	91: MoveLoc[0](self: &mut ValidatorSet)
	92: MutBorrowField[4](ValidatorSet.next_epoch_validators: vector<ValidatorMetadata>)
	93: WriteRef
	94: Ret
}
public(friend) request_withdraw_delegation(self: &mut ValidatorSet, delegation: Delegation, staked_sui: StakedSui, ctx: &mut TxContext) {
B0:
	0: ImmBorrowLoc[2](staked_sui: StakedSui)
	1: Call staking_pool::validator_address(&StakedSui): address
	2: StLoc[4](validator_address: address)
	3: CopyLoc[0](self: &mut ValidatorSet)
	4: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	5: MoveLoc[4](validator_address: address)
	6: Call find_validator(&vector<Validator>, address): Option<u64>
	7: StLoc[6](validator_index_opt: Option<u64>)
	8: ImmBorrowLoc[6](validator_index_opt: Option<u64>)
	9: Call option::is_some<u64>(&Option<u64>): bool
	10: BrFalse(12)
B1:
	11: Branch(18)
B2:
	12: MoveLoc[0](self: &mut ValidatorSet)
	13: Pop
	14: MoveLoc[3](ctx: &mut TxContext)
	15: Pop
	16: LdU64(0)
	17: Abort
B3:
	18: MutBorrowLoc[6](validator_index_opt: Option<u64>)
	19: Call option::extract<u64>(&mut Option<u64>): u64
	20: StLoc[5](validator_index: u64)
	21: CopyLoc[0](self: &mut ValidatorSet)
	22: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	23: MoveLoc[5](validator_index: u64)
	24: VecMutBorrow(42)
	25: MoveLoc[1](delegation: Delegation)
	26: MoveLoc[2](staked_sui: StakedSui)
	27: MoveLoc[3](ctx: &mut TxContext)
	28: Call validator::request_withdraw_delegation(&mut Validator, Delegation, StakedSui, &mut TxContext)
	29: CopyLoc[0](self: &mut ValidatorSet)
	30: FreezeRef
	31: Call derive_next_epoch_validators(&ValidatorSet): vector<ValidatorMetadata>
	32: MoveLoc[0](self: &mut ValidatorSet)
	33: MutBorrowField[4](ValidatorSet.next_epoch_validators: vector<ValidatorMetadata>)
	34: WriteRef
	35: Ret
}
public(friend) request_withdraw_stake(self: &mut ValidatorSet, stake: &mut Stake, withdraw_amount: u64, min_validator_stake: u64, ctx: &mut TxContext) {
B0:
	0: CopyLoc[4](ctx: &mut TxContext)
	1: FreezeRef
	2: Call tx_context::sender(&TxContext): address
	3: StLoc[5](validator_address: address)
	4: CopyLoc[0](self: &mut ValidatorSet)
	5: MutBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	6: MoveLoc[5](validator_address: address)
	7: Call get_validator_mut(&mut vector<Validator>, address): &mut Validator
	8: MoveLoc[1](stake: &mut Stake)
	9: MoveLoc[2](withdraw_amount: u64)
	10: MoveLoc[3](min_validator_stake: u64)
	11: MoveLoc[4](ctx: &mut TxContext)
	12: Call validator::request_withdraw_stake(&mut Validator, &mut Stake, u64, u64, &mut TxContext)
	13: CopyLoc[0](self: &mut ValidatorSet)
	14: FreezeRef
	15: Call derive_next_epoch_validators(&ValidatorSet): vector<ValidatorMetadata>
	16: MoveLoc[0](self: &mut ValidatorSet)
	17: MutBorrowField[4](ValidatorSet.next_epoch_validators: vector<ValidatorMetadata>)
	18: WriteRef
	19: Ret
}
sort_removal_list(withdraw_list: &mut vector<u64>) {
L0:	%#4: u64
L1:	cur: u64
L2:	i: u64
L3:	j: u64
L4:	length: u64
B0:
	0: CopyLoc[0](withdraw_list: &mut vector<u64>)
	1: FreezeRef
	2: VecLen(17)
	3: StLoc[6](length: u64)
	4: LdU64(1)
	5: StLoc[4](i: u64)
B1:
	6: CopyLoc[4](i: u64)
	7: CopyLoc[6](length: u64)
	8: Lt
	9: BrFalse(54)
B2:
	10: Branch(11)
B3:
	11: CopyLoc[0](withdraw_list: &mut vector<u64>)
	12: CopyLoc[4](i: u64)
	13: StLoc[1](%#2: u64)
	14: FreezeRef
	15: MoveLoc[1](%#2: u64)
	16: VecImmBorrow(17)
	17: ReadRef
	18: StLoc[3](cur: u64)
	19: CopyLoc[4](i: u64)
	20: StLoc[5](j: u64)
B4:
	21: CopyLoc[5](j: u64)
	22: LdU64(0)
	23: Gt
	24: BrFalse(49)
B5:
	25: Branch(26)
B6:
	26: MoveLoc[5](j: u64)
	27: LdU64(1)
	28: Sub
	29: StLoc[5](j: u64)
	30: CopyLoc[0](withdraw_list: &mut vector<u64>)
	31: CopyLoc[5](j: u64)
	32: StLoc[2](%#4: u64)
	33: FreezeRef
	34: MoveLoc[2](%#4: u64)
	35: VecImmBorrow(17)
	36: ReadRef
	37: CopyLoc[3](cur: u64)
	38: Gt
	39: BrFalse(41)
B7:
	40: Branch(42)
B8:
	41: Branch(49)
B9:
	42: CopyLoc[0](withdraw_list: &mut vector<u64>)
	43: CopyLoc[5](j: u64)
	44: CopyLoc[5](j: u64)
	45: LdU64(1)
	46: Add
	47: VecSwap(17)
	48: Branch(21)
B10:
	49: MoveLoc[4](i: u64)
	50: LdU64(1)
	51: Add
	52: StLoc[4](i: u64)
	53: Branch(6)
B11:
	54: MoveLoc[0](withdraw_list: &mut vector<u64>)
	55: Pop
	56: Ret
}
public sum_voting_power_by_addresses(vs: &vector<Validator>, addresses: &vector<address>): u64 {
L0:	sum: u64
L1:	validator: &Validator
B0:
	0: LdU64(0)
	1: StLoc[4](sum: u64)
	2: LdU64(0)
	3: StLoc[2](i: u64)
	4: CopyLoc[1](addresses: &vector<address>)
	5: VecLen(47)
	6: StLoc[3](length: u64)
B1:
	7: CopyLoc[2](i: u64)
	8: CopyLoc[3](length: u64)
	9: Lt
	10: BrFalse(29)
B2:
	11: Branch(12)
B3:
	12: CopyLoc[0](vs: &vector<Validator>)
	13: CopyLoc[1](addresses: &vector<address>)
	14: CopyLoc[2](i: u64)
	15: VecImmBorrow(47)
	16: ReadRef
	17: Call get_validator_ref(&vector<Validator>, address): &Validator
	18: StLoc[5](validator: &Validator)
	19: MoveLoc[4](sum: u64)
	20: MoveLoc[5](validator: &Validator)
	21: Call validator::voting_power(&Validator): u64
	22: Add
	23: StLoc[4](sum: u64)
	24: MoveLoc[2](i: u64)
	25: LdU64(1)
	26: Add
	27: StLoc[2](i: u64)
	28: Branch(7)
B4:
	29: MoveLoc[0](vs: &vector<Validator>)
	30: Pop
	31: MoveLoc[1](addresses: &vector<address>)
	32: Pop
	33: MoveLoc[4](sum: u64)
	34: Ret
}
public total_delegation_stake(self: &ValidatorSet): u64 {
B0:
	0: MoveLoc[0](self: &ValidatorSet)
	1: ImmBorrowField[2](ValidatorSet.total_delegation_stake: u64)
	2: ReadRef
	3: Ret
}
public total_validator_stake(self: &ValidatorSet): u64 {
B0:
	0: MoveLoc[0](self: &ValidatorSet)
	1: ImmBorrowField[1](ValidatorSet.total_validator_stake: u64)
	2: ReadRef
	3: Ret
}
public validator_delegate_amount(self: &ValidatorSet, validator_address: address): u64 {
B0:
	0: MoveLoc[0](self: &ValidatorSet)
	1: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	2: MoveLoc[1](validator_address: address)
	3: Call get_validator_ref(&vector<Validator>, address): &Validator
	4: Call validator::delegate_amount(&Validator): u64
	5: Ret
}
public validator_stake_amount(self: &ValidatorSet, validator_address: address): u64 {
B0:
	0: MoveLoc[0](self: &ValidatorSet)
	1: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	2: MoveLoc[1](validator_address: address)
	3: Call get_validator_ref(&vector<Validator>, address): &Validator
	4: Call validator::stake_amount(&Validator): u64
	5: Ret
}
public validator_total_stake_amount(self: &ValidatorSet, validator_address: address): u64 {
B0:
	0: MoveLoc[0](self: &ValidatorSet)
	1: ImmBorrowField[0](ValidatorSet.active_validators: vector<Validator>)
	2: MoveLoc[1](validator_address: address)
	3: Call get_validator_ref(&vector<Validator>, address): &Validator
	4: Call validator::total_stake_amount(&Validator): u64
	5: Ret
}
}
