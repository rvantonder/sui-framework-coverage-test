// Move bytecode v6
module 2.locked_coin {
use 0000000000000000000000000000000000000002::balance;
use 0000000000000000000000000000000000000002::coin;
use 0000000000000000000000000000000000000002::epoch_time_lock;
use 0000000000000000000000000000000000000002::object;
use 0000000000000000000000000000000000000002::transfer;
use 0000000000000000000000000000000000000002::tx_context;


struct LockedCoin<phantom T> has key {
	id: UID,
	balance: Balance<T>,
	locked_until_epoch: EpochTimeLock
}

public new_from_balance<T>(balance#0#0: Balance<T>, locked_until_epoch#0#0: EpochTimeLock, owner#0#0: address, ctx#0#0: &mut TxContext) {
B0:
	0: MoveLoc[3](ctx#0#0: &mut TxContext)
	1: Call object::new(&mut TxContext): UID
	2: MoveLoc[0](balance#0#0: Balance<T>)
	3: MoveLoc[1](locked_until_epoch#0#0: EpochTimeLock)
	4: PackGeneric[0](LockedCoin<T>)
	5: MoveLoc[2](owner#0#0: address)
	6: Call transfer::transfer<LockedCoin<T>>(LockedCoin<T>, address)
	7: Ret
}
public(friend) into_balance<T>(coin#0#0: LockedCoin<T>): Balance<T> * EpochTimeLock {
L0:	locked_until_epoch#1#0: EpochTimeLock
B0:
	0: MoveLoc[0](coin#0#0: LockedCoin<T>)
	1: UnpackGeneric[0](LockedCoin<T>)
	2: StLoc[2](locked_until_epoch#1#0: EpochTimeLock)
	3: StLoc[1](balance#1#0: Balance<T>)
	4: Call object::delete(UID)
	5: MoveLoc[1](balance#1#0: Balance<T>)
	6: MoveLoc[2](locked_until_epoch#1#0: EpochTimeLock)
	7: Ret
}
public value<T>(self#0#0: &LockedCoin<T>): u64 {
B0:
	0: MoveLoc[0](self#0#0: &LockedCoin<T>)
	1: ImmBorrowFieldGeneric[0](LockedCoin.balance: Balance<T>)
	2: Call balance::value<T>(&Balance<T>): u64
	3: Ret
}
entry public lock_coin<T>(coin#0#0: Coin<T>, recipient#0#0: address, locked_until_epoch#0#0: u64, ctx#0#0: &mut TxContext) {
B0:
	0: MoveLoc[0](coin#0#0: Coin<T>)
	1: Call coin::into_balance<T>(Coin<T>): Balance<T>
	2: StLoc[6](%#3: Balance<T>)
	3: MoveLoc[2](locked_until_epoch#0#0: u64)
	4: CopyLoc[3](ctx#0#0: &mut TxContext)
	5: StLoc[5](%#2: &mut TxContext)
	6: StLoc[4](%#1: u64)
	7: MoveLoc[6](%#3: Balance<T>)
	8: MoveLoc[4](%#1: u64)
	9: MoveLoc[5](%#2: &mut TxContext)
	10: FreezeRef
	11: Call epoch_time_lock::new(u64, &TxContext): EpochTimeLock
	12: MoveLoc[1](recipient#0#0: address)
	13: MoveLoc[3](ctx#0#0: &mut TxContext)
	14: Call new_from_balance<T>(Balance<T>, EpochTimeLock, address, &mut TxContext)
	15: Ret
}
entry public unlock_coin<T>(locked_coin#0#0: LockedCoin<T>, ctx#0#0: &mut TxContext) {
B0:
	0: MoveLoc[0](locked_coin#0#0: LockedCoin<T>)
	1: UnpackGeneric[0](LockedCoin<T>)
	2: StLoc[3](locked_until_epoch#1#0: EpochTimeLock)
	3: StLoc[2](balance#1#0: Balance<T>)
	4: Call object::delete(UID)
	5: MoveLoc[3](locked_until_epoch#1#0: EpochTimeLock)
	6: CopyLoc[1](ctx#0#0: &mut TxContext)
	7: FreezeRef
	8: Call epoch_time_lock::destroy(EpochTimeLock, &TxContext)
	9: MoveLoc[2](balance#1#0: Balance<T>)
	10: CopyLoc[1](ctx#0#0: &mut TxContext)
	11: Call coin::from_balance<T>(Balance<T>, &mut TxContext): Coin<T>
	12: MoveLoc[1](ctx#0#0: &mut TxContext)
	13: FreezeRef
	14: Call tx_context::sender(&TxContext): address
	15: Call transfer::transfer<Coin<T>>(Coin<T>, address)
	16: Ret
}
}
