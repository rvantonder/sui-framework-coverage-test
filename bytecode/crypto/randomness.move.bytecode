// Move bytecode v6
module 2.randomness {
use 0000000000000000000000000000000000000001::hash;
use 0000000000000000000000000000000000000001::option;
use 0000000000000000000000000000000000000001::vector;
use 0000000000000000000000000000000000000002::bcs;
use 0000000000000000000000000000000000000002::object;
use 0000000000000000000000000000000000000002::transfer;
use 0000000000000000000000000000000000000002::tx_context;


struct Randomness<phantom T> has key {
	id: UID,
	epoch: u64,
	value: Option<vector<u8>>
}

public new<T: drop>(_w#0#0: T, ctx#0#0: &mut TxContext): Randomness<T> {
B0:
	0: CopyLoc[1](ctx#0#0: &mut TxContext)
	1: Call object::new(&mut TxContext): UID
	2: MoveLoc[1](ctx#0#0: &mut TxContext)
	3: FreezeRef
	4: Call tx_context::epoch(&TxContext): u64
	5: Call option::none<vector<u8>>(): Option<vector<u8>>
	6: PackGeneric[0](Randomness<T>)
	7: Ret
}
public transfer<T>(self#0#0: Randomness<T>, to#0#0: address) {
B0:
	0: MoveLoc[0](self#0#0: Randomness<T>)
	1: MoveLoc[1](to#0#0: address)
	2: Call transfer::transfer<Randomness<T>>(Randomness<T>, address)
	3: Ret
}
public share_object<T>(self#0#0: Randomness<T>) {
B0:
	0: MoveLoc[0](self#0#0: Randomness<T>)
	1: Call transfer::share_object<Randomness<T>>(Randomness<T>)
	2: Ret
}
public set<T>(self#0#0: &mut Randomness<T>, sig#0#0: vector<u8>) {
L0:	%#3: vector<u8>
L1:	%#4: &vector<u8>
L2:	msg#1#0: vector<u8>
B0:
	0: CopyLoc[0](self#0#0: &mut Randomness<T>)
	1: ImmBorrowFieldGeneric[0](Randomness.value: Option<vector<u8>>)
	2: Call option::is_none<vector<u8>>(&Option<vector<u8>>): bool
	3: BrFalse(5)
B1:
	4: Branch(9)
B2:
	5: MoveLoc[0](self#0#0: &mut Randomness<T>)
	6: Pop
	7: LdConst[1](U64: [1, 0, 0, 0, 0, 0, 0, 0])
	8: Abort
B3:
	9: LdConst[3](Vector(U8): [10, 114, 97, 110, 100, 111, 109, 110, 101, 115, 115])
	10: StLoc[4](%#3: vector<u8>)
	11: ImmBorrowLoc[4](%#3: vector<u8>)
	12: StLoc[5](%#4: &vector<u8>)
	13: CopyLoc[0](self#0#0: &mut Randomness<T>)
	14: ImmBorrowFieldGeneric[1](Randomness.epoch: u64)
	15: ReadRef
	16: StLoc[3](%#2: u64)
	17: CopyLoc[0](self#0#0: &mut Randomness<T>)
	18: FreezeRef
	19: Call object::id<Randomness<T>>(&Randomness<T>): ID
	20: StLoc[2](%#1: ID)
	21: MoveLoc[5](%#4: &vector<u8>)
	22: MoveLoc[3](%#2: u64)
	23: ImmBorrowLoc[2](%#1: ID)
	24: Call to_bytes(&vector<u8>, u64, &ID): vector<u8>
	25: StLoc[6](msg#1#0: vector<u8>)
	26: CopyLoc[0](self#0#0: &mut Randomness<T>)
	27: ImmBorrowFieldGeneric[1](Randomness.epoch: u64)
	28: ReadRef
	29: ImmBorrowLoc[6](msg#1#0: vector<u8>)
	30: ImmBorrowLoc[1](sig#0#0: vector<u8>)
	31: Call native_tbls_verify_signature(u64, &vector<u8>, &vector<u8>): bool
	32: BrFalse(34)
B4:
	33: Branch(38)
B5:
	34: MoveLoc[0](self#0#0: &mut Randomness<T>)
	35: Pop
	36: LdConst[0](U64: [0, 0, 0, 0, 0, 0, 0, 0])
	37: Abort
B6:
	38: MoveLoc[1](sig#0#0: vector<u8>)
	39: Call hash::sha3_256(vector<u8>): vector<u8>
	40: Call option::some<vector<u8>>(vector<u8>): Option<vector<u8>>
	41: MoveLoc[0](self#0#0: &mut Randomness<T>)
	42: MutBorrowFieldGeneric[0](Randomness.value: Option<vector<u8>>)
	43: WriteRef
	44: Ret
}
public destroy<T>(r#0#0: Randomness<T>) {
B0:
	0: MoveLoc[0](r#0#0: Randomness<T>)
	1: UnpackGeneric[0](Randomness<T>)
	2: Pop
	3: Pop
	4: Call object::delete(UID)
	5: Ret
}
public epoch<T>(self#0#0: &Randomness<T>): u64 {
B0:
	0: MoveLoc[0](self#0#0: &Randomness<T>)
	1: ImmBorrowFieldGeneric[1](Randomness.epoch: u64)
	2: ReadRef
	3: Ret
}
public value<T>(self#0#0: &Randomness<T>): &Option<vector<u8>> {
B0:
	0: MoveLoc[0](self#0#0: &Randomness<T>)
	1: ImmBorrowFieldGeneric[0](Randomness.value: Option<vector<u8>>)
	2: Ret
}
to_bytes(domain#0#0: &vector<u8>, epoch#0#0: u64, id#0#0: &ID): vector<u8> {
B0:
	0: VecPack(23, 0)
	1: StLoc[3](buffer#1#0: vector<u8>)
	2: MutBorrowLoc[3](buffer#1#0: vector<u8>)
	3: MoveLoc[0](domain#0#0: &vector<u8>)
	4: ReadRef
	5: Call vector::append<u8>(&mut vector<u8>, vector<u8>)
	6: MutBorrowLoc[3](buffer#1#0: vector<u8>)
	7: ImmBorrowLoc[1](epoch#0#0: u64)
	8: Call bcs::to_bytes<u64>(&u64): vector<u8>
	9: Call vector::append<u8>(&mut vector<u8>, vector<u8>)
	10: MutBorrowLoc[3](buffer#1#0: vector<u8>)
	11: MoveLoc[2](id#0#0: &ID)
	12: Call object::id_to_bytes(&ID): vector<u8>
	13: Call vector::append<u8>(&mut vector<u8>, vector<u8>)
	14: MoveLoc[3](buffer#1#0: vector<u8>)
	15: Ret
}
native native_tbls_verify_signature(epoch#0#0: u64, msg#0#0: &vector<u8>, sig#0#0: &vector<u8>): bool
native native_tbls_sign(epoch#0#0: u64, msg#0#0: &vector<u8>): vector<u8>
public safe_selection(n#0#0: u64, rnd#0#0: &vector<u8>): u64 {
L0:	m#1#0: u128
L1:	n_128#1#0: u128
B0:
	0: CopyLoc[1](rnd#0#0: &vector<u8>)
	1: VecLen(23)
	2: LdU64(16)
	3: Ge
	4: BrFalse(6)
B1:
	5: Branch(10)
B2:
	6: MoveLoc[1](rnd#0#0: &vector<u8>)
	7: Pop
	8: LdConst[2](U64: [2, 0, 0, 0, 0, 0, 0, 0])
	9: Abort
B3:
	10: LdU128(0)
	11: StLoc[4](m#1#0: u128)
	12: LdU64(0)
	13: StLoc[3](i#1#0: u64)
B4:
	14: CopyLoc[3](i#1#0: u64)
	15: LdU64(16)
	16: Lt
	17: BrFalse(38)
B5:
	18: Branch(19)
B6:
	19: MoveLoc[4](m#1#0: u128)
	20: LdU8(8)
	21: Shl
	22: StLoc[4](m#1#0: u128)
	23: CopyLoc[1](rnd#0#0: &vector<u8>)
	24: CopyLoc[3](i#1#0: u64)
	25: VecImmBorrow(23)
	26: ReadRef
	27: StLoc[2](curr_byte#1#0: u8)
	28: MoveLoc[4](m#1#0: u128)
	29: MoveLoc[2](curr_byte#1#0: u8)
	30: CastU128
	31: Add
	32: StLoc[4](m#1#0: u128)
	33: MoveLoc[3](i#1#0: u64)
	34: LdU64(1)
	35: Add
	36: StLoc[3](i#1#0: u64)
	37: Branch(14)
B7:
	38: MoveLoc[1](rnd#0#0: &vector<u8>)
	39: Pop
	40: MoveLoc[0](n#0#0: u64)
	41: CastU128
	42: StLoc[5](n_128#1#0: u128)
	43: MoveLoc[4](m#1#0: u128)
	44: MoveLoc[5](n_128#1#0: u128)
	45: Mod
	46: CastU64
	47: Ret
}
}
