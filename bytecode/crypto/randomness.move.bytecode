// Move bytecode v6
module 2.randomness {
use 0000000000000000000000000000000000000001::hash;
use 0000000000000000000000000000000000000001::option;
use 0000000000000000000000000000000000000001::vector;
use 0000000000000000000000000000000000000002::bcs;
use 0000000000000000000000000000000000000002::object;
use 0000000000000000000000000000000000000002::transfer;
use 0000000000000000000000000000000000000002::tx_context;


struct Randomness<phantom T> has key {
	id: UID,
	epoch: u64,
	value: Option<vector<u8>>
}

public destroy<T>(r: Randomness<T>) {
B0:
	0: MoveLoc[0](r: Randomness<T>)
	1: UnpackGeneric[0](Randomness<T>)
	2: Pop
	3: Pop
	4: Call object::delete(UID)
	5: Ret
}
public epoch<T>(self: &Randomness<T>): u64 {
B0:
	0: MoveLoc[0](self: &Randomness<T>)
	1: ImmBorrowFieldGeneric[0](Randomness.epoch: u64)
	2: ReadRef
	3: Ret
}
native native_tbls_sign(epoch: u64, msg: &vector<u8>): vector<u8>
native native_tbls_verify_signature(epoch: u64, msg: &vector<u8>, sig: &vector<u8>): bool
public new<T: drop>(_w: T, ctx: &mut TxContext): Randomness<T> {
B0:
	0: CopyLoc[1](ctx: &mut TxContext)
	1: Call object::new(&mut TxContext): UID
	2: MoveLoc[1](ctx: &mut TxContext)
	3: FreezeRef
	4: Call tx_context::epoch(&TxContext): u64
	5: Call option::none<vector<u8>>(): Option<vector<u8>>
	6: PackGeneric[0](Randomness<T>)
	7: Ret
}
public safe_selection(n: u64, rnd: &vector<u8>): u64 {
L0:	m: u128
L1:	n_128: u128
B0:
	0: CopyLoc[1](rnd: &vector<u8>)
	1: VecLen(19)
	2: LdU64(16)
	3: Ge
	4: BrFalse(6)
B1:
	5: Branch(10)
B2:
	6: MoveLoc[1](rnd: &vector<u8>)
	7: Pop
	8: LdConst[2](U64: [2, 0, 0, 0, 0, 0, 0, 0])
	9: Abort
B3:
	10: LdU128(0)
	11: StLoc[4](m: u128)
	12: LdU64(0)
	13: StLoc[3](i: u64)
B4:
	14: CopyLoc[3](i: u64)
	15: LdU64(16)
	16: Lt
	17: BrFalse(38)
B5:
	18: Branch(19)
B6:
	19: MoveLoc[4](m: u128)
	20: LdU8(8)
	21: Shl
	22: StLoc[4](m: u128)
	23: CopyLoc[1](rnd: &vector<u8>)
	24: CopyLoc[3](i: u64)
	25: VecImmBorrow(19)
	26: ReadRef
	27: StLoc[2](curr_byte: u8)
	28: MoveLoc[4](m: u128)
	29: MoveLoc[2](curr_byte: u8)
	30: CastU128
	31: Add
	32: StLoc[4](m: u128)
	33: MoveLoc[3](i: u64)
	34: LdU64(1)
	35: Add
	36: StLoc[3](i: u64)
	37: Branch(14)
B7:
	38: MoveLoc[1](rnd: &vector<u8>)
	39: Pop
	40: MoveLoc[0](n: u64)
	41: CastU128
	42: StLoc[5](n_128: u128)
	43: MoveLoc[4](m: u128)
	44: MoveLoc[5](n_128: u128)
	45: Mod
	46: CastU64
	47: Ret
}
public set<T>(self: &mut Randomness<T>, sig: vector<u8>) {
L0:	%#3: vector<u8>
L1:	%#4: &vector<u8>
L2:	msg: vector<u8>
B0:
	0: CopyLoc[0](self: &mut Randomness<T>)
	1: ImmBorrowFieldGeneric[1](Randomness.value: Option<vector<u8>>)
	2: Call option::is_none<vector<u8>>(&Option<vector<u8>>): bool
	3: BrFalse(5)
B1:
	4: Branch(9)
B2:
	5: MoveLoc[0](self: &mut Randomness<T>)
	6: Pop
	7: LdConst[1](U64: [1, 0, 0, 0, 0, 0, 0, 0])
	8: Abort
B3:
	9: LdConst[0](Vector(U8): [10, 114, 97, 110, 100, 111, 109, 110, 101, 115, 115])
	10: StLoc[4](%#3: vector<u8>)
	11: ImmBorrowLoc[4](%#3: vector<u8>)
	12: StLoc[5](%#4: &vector<u8>)
	13: CopyLoc[0](self: &mut Randomness<T>)
	14: ImmBorrowFieldGeneric[0](Randomness.epoch: u64)
	15: ReadRef
	16: StLoc[3](%#2: u64)
	17: CopyLoc[0](self: &mut Randomness<T>)
	18: FreezeRef
	19: Call object::id<Randomness<T>>(&Randomness<T>): ID
	20: StLoc[2](%#1: ID)
	21: MoveLoc[5](%#4: &vector<u8>)
	22: MoveLoc[3](%#2: u64)
	23: ImmBorrowLoc[2](%#1: ID)
	24: Call to_bytes(&vector<u8>, u64, &ID): vector<u8>
	25: StLoc[6](msg: vector<u8>)
	26: CopyLoc[0](self: &mut Randomness<T>)
	27: ImmBorrowFieldGeneric[0](Randomness.epoch: u64)
	28: ReadRef
	29: ImmBorrowLoc[6](msg: vector<u8>)
	30: ImmBorrowLoc[1](sig: vector<u8>)
	31: Call native_tbls_verify_signature(u64, &vector<u8>, &vector<u8>): bool
	32: BrFalse(34)
B4:
	33: Branch(38)
B5:
	34: MoveLoc[0](self: &mut Randomness<T>)
	35: Pop
	36: LdConst[3](U64: [0, 0, 0, 0, 0, 0, 0, 0])
	37: Abort
B6:
	38: MoveLoc[1](sig: vector<u8>)
	39: Call hash::sha3_256(vector<u8>): vector<u8>
	40: Call option::some<vector<u8>>(vector<u8>): Option<vector<u8>>
	41: MoveLoc[0](self: &mut Randomness<T>)
	42: MutBorrowFieldGeneric[1](Randomness.value: Option<vector<u8>>)
	43: WriteRef
	44: Ret
}
public share_object<T>(self: Randomness<T>) {
B0:
	0: MoveLoc[0](self: Randomness<T>)
	1: Call transfer::share_object<Randomness<T>>(Randomness<T>)
	2: Ret
}
to_bytes(domain: &vector<u8>, epoch: u64, id: &ID): vector<u8> {
B0:
	0: VecPack(19, 0)
	1: StLoc[3](buffer: vector<u8>)
	2: MutBorrowLoc[3](buffer: vector<u8>)
	3: MoveLoc[0](domain: &vector<u8>)
	4: ReadRef
	5: Call vector::append<u8>(&mut vector<u8>, vector<u8>)
	6: MutBorrowLoc[3](buffer: vector<u8>)
	7: ImmBorrowLoc[1](epoch: u64)
	8: Call bcs::to_bytes<u64>(&u64): vector<u8>
	9: Call vector::append<u8>(&mut vector<u8>, vector<u8>)
	10: MutBorrowLoc[3](buffer: vector<u8>)
	11: MoveLoc[2](id: &ID)
	12: Call object::id_to_bytes(&ID): vector<u8>
	13: Call vector::append<u8>(&mut vector<u8>, vector<u8>)
	14: MoveLoc[3](buffer: vector<u8>)
	15: Ret
}
public transfer<T>(self: Randomness<T>, to: address) {
B0:
	0: MoveLoc[0](self: Randomness<T>)
	1: MoveLoc[1](to: address)
	2: Call transfer::transfer<Randomness<T>>(Randomness<T>, address)
	3: Ret
}
public value<T>(self: &Randomness<T>): &Option<vector<u8>> {
B0:
	0: MoveLoc[0](self: &Randomness<T>)
	1: ImmBorrowFieldGeneric[1](Randomness.value: Option<vector<u8>>)
	2: Ret
}
}
